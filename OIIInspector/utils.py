import argparse
import subprocess
import shlex
import logging
import json
import re


def setup_arg_parser(args: dict) -> argparse.ArgumentParser:
    """
    Set up ArgumentParser with the provided arguments.
    :param args: Dictionary of argument aliases and options to be consumed by ArgumentParser.
    :type args: (dict)
    :return: Configured instance of ArgumentParser.
    :rtype: ArgumentParser
    """
    parser = argparse.ArgumentParser()
    arg_groups = {}
    for aliases, arg_data in args.items():
        holder = parser
        if "group" in arg_data:
            arg_groups.setdefault(
                arg_data["group"], parser.add_argument_group(arg_data["group"])
            )
            holder = arg_groups[arg_data["group"]]
        action = arg_data.get("action")
        if not action and arg_data["type"] == bool:
            action = "store_true"
        kwargs = {
            "help": arg_data.get("help"),
            "required": arg_data.get("required", False),
            "default": arg_data.get("default"),
        }
        if action:
            kwargs["action"] = action
        else:
            kwargs["type"] = arg_data.get("type", "str")
            kwargs["nargs"] = arg_data.get("count")

        holder.add_argument(*aliases, **kwargs)

    return parser


def run_cmd(cmd: str, err_msg: str = None, tolerate_err: bool = False) -> (str, str):
    """
    Run a command locally.

    :param cmd: Shell command to be executed.
    :type cmd: str
    :param err_msg: Error message written when the command fails.
    :type err_msg: str
    :param tolerate_err: Whether to tolerate a failed command.
    :type tolerate_err: bool
    :return: Tuple of stdout and stderr generated by the command.
    :rtype: tuple of (str, str):
    """
    log = logging.getLogger("OIIInspector")
    err_msg = err_msg or "An error has occurred when executing a command."
    p = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    if p.returncode != 0 and not tolerate_err:
        log.error(f"Command {cmd} failed with {err}")
        raise RuntimeError(err_msg)

    return out.decode('utf-8')


def convert_output(api_response: str) -> str:
    """
    Converts answer from API into JSON

    :param api_response: String received from grpcurl call on api.Registry
    :type api_response: str
    :return: JSON-object that is possible to convert into string.
    :rtype: str
    """

    log = logging.getLogger("OIIInspector")
    if api_response == "":
        log.error("Answer from API is empty")
        raise RuntimeError("Answer from API is empty")

    api_response = re.sub(r'}\s*{', "} ,{", api_response)
    json_data = json.loads(api_response)
    if 'csvJson' in json_data:
        json_data['csvJson'] = json.loads(json_data['csvJson'])

    if 'object' in json_data:
        new_object = []
        for item in json_data['object']:
            new_object.append(json.loads(item))
        json_data['object'] = new_object
    if 'spec' in json_data:
        json_data['spec'] = json.loads(json_data['spec'])
    return json_data
