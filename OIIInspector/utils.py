import argparse
import subprocess
import shlex
import logging
import json
import re


def setup_arg_parser(args):
    """
    Set up ArgumentParser with the provided arguments.
    Args:
        args (dict)
            Dictionary of argument aliases and options to be consumed by ArgumentParser.
    Returns:
        (ArgumentParser) Configured instance of ArgumentParser.
    """
    parser = argparse.ArgumentParser()
    arg_groups = {}
    for aliases, arg_data in args.items():
        holder = parser
        if "group" in arg_data:
            arg_groups.setdefault(
                arg_data["group"], parser.add_argument_group(arg_data["group"])
            )
            holder = arg_groups[arg_data["group"]]
        action = arg_data.get("action")
        if not action and arg_data["type"] == bool:
            action = "store_true"
        kwargs = {
            "help": arg_data.get("help"),
            "required": arg_data.get("required", False),
            "default": arg_data.get("default"),
        }
        if action:
            kwargs["action"] = action
        else:
            kwargs["type"] = arg_data.get("type", "str")
            kwargs["nargs"] = arg_data.get("count")

        holder.add_argument(*aliases, **kwargs)

    return parser


def run_cmd(cmd, err_msg=None, tolerate_err=False):
    """
    Run a command locally.
    Args:
        cmd (str):
            Shell command to be executed.
        err_msg (str):
            Error message written when the command fails.
        tolerate_err (bool):
            Whether to tolerate a failed command.

    Returns (str, str):
        Tuple of stdout and stderr generated by the command.
    """
    log = logging.getLogger("OIIInspector")
    err_msg = err_msg or "An error has occurred when executing a command."
    p = subprocess.Popen(shlex.split(cmd), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    out, err = p.communicate()
    if p.returncode != 0 and not tolerate_err:
        log.error(f"Command {cmd} failed with {err}")
        raise RuntimeError(err_msg)

    return out.decode('utf-8')


def convert_output(api_response):
    """
    Converts answer from API into JSON
    Args:
        api_response (str):
            String received from grpcurl call on api.Registry

    Returns (str)
        String already convertible into JSON format.
    """

    log = logging.getLogger("OIIInspector")
    if api_response == "":
        log.error("Answer from API is empty")
        raise RuntimeError("Answer from API is empty")

    api_response = re.sub(r'}\s*{', "} ,{", api_response)
    json_data = json.loads(api_response)
    if 'csvJson' in json_data:
        json_data['csvJson'] = json.loads(json_data['csvJson'])

    if 'object' in json_data:
        new_object = []
        for item in json_data['object']:
            new_object.append(json.loads(item))
        json_data['object'] = new_object
    if 'spec' in json_data:
        json_data['spec'] = json.loads(json_data['spec'])
    return json_data
