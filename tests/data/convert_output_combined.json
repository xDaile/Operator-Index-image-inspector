{
  "csvName": "datagrid-operator.v8.2.0",
  "packageName": "datagrid",
  "channelName": "8.2.x",
  "csvJson": "{\"apiVersion\":\"operators.coreos.com/v1alpha1\",\"kind\":\"ClusterServiceVersion\",\"metadata\":{\"annotations\":{\"alm-examples\":\"[\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v1\\\",\\n    \\\"kind\\\": \\\"Infinispan\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-infinispan\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"replicas\\\": 1\\n    }\\n  },\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v2alpha1\\\",\\n    \\\"kind\\\": \\\"Backup\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-backup\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"cluster\\\": \\\"example-infinispan\\\",\\n      \\\"container\\\": {\\n        \\\"cpu\\\": \\\"1000m\\\",\\n        \\\"extraJvmOpts\\\": \\\"-Djava.property=me\\\",\\n        \\\"memory\\\": \\\"1Gi\\\"\\n      }\\n    }\\n  },\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v2alpha1\\\",\\n    \\\"kind\\\": \\\"Cache\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-cache\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"adminAuth\\\": {\\n        \\\"secretName\\\": \\\"basic-auth\\\"\\n      },\\n      \\\"clusterName\\\": \\\"example-infinispan\\\",\\n      \\\"name\\\": \\\"mycache\\\"\\n    }\\n  },\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v2alpha1\\\",\\n    \\\"kind\\\": \\\"Restore\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-restore\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"cluster\\\": \\\"example-infinispan\\\",\\n      \\\"container\\\": {\\n        \\\"cpu\\\": \\\"1000m\\\",\\n        \\\"extraJvmOpts\\\": \\\"-Djava.property=me\\\",\\n        \\\"memory\\\": \\\"1Gi\\\"\\n      }\\n    }\\n  },\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v2alpha1\\\",\\n    \\\"kind\\\": \\\"Batch\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-batch\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"cluster\\\": \\\"example-infinispan\\\",\\n      \\\"config\\\": \\\"create cache --template=org.infinispan.DIST_SYNC batch-cache\\\"\\n    }\\n  }\\n]\",\"capabilities\":\"Full Lifecycle\",\"categories\":\"Database\",\"certified\":\"false\",\"containerImage\":\"registry.redhat.io/datagrid/datagrid-8-rhel8-operator@sha256:d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5\",\"createdAt\":\"2021-05-17T15:34:29Z\",\"description\":\"Create and manage Red Hat Data Grid clusters.\",\"operators.openshift.io/infrastructure-features\":\"[\\\"Disconnected\\\"]\",\"repository\":\"https://github.com/infinispan/infinispan-operator\",\"support\":\"Red Hat\"},\"labels\":{\"operatorframework.io/arch.amd64\":\"supported\",\"operatorframework.io/arch.ppc64le\":\"supported\",\"operatorframework.io/arch.s390x\":\"supported\"},\"name\":\"datagrid-operator.v8.2.0\",\"namespace\":\"placeholder\"},\"spec\":{\"apiservicedefinitions\":{},\"customresourcedefinitions\":{\"owned\":[{\"description\":\"Backup is the Schema for the backups API\",\"displayName\":\"Backup\",\"kind\":\"Backup\",\"name\":\"backups.infinispan.org\",\"specDescriptors\":[{\"description\":\"Names your Infinispan cluster.\",\"displayName\":\"Cluster name\",\"path\":\"cluster\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v1:Infinispan\"]},{\"description\":\"Names the storage class object for persistent volume claims.\",\"displayName\":\"Storage class name\",\"path\":\"volume.storageClassName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:StorageClass\"]}],\"version\":\"v2alpha1\"},{\"description\":\"Restore API schema.\",\"displayName\":\"Restore\",\"kind\":\"Restore\",\"name\":\"restores.infinispan.org\",\"specDescriptors\":[{\"description\":\"Infinispan cluster name\",\"displayName\":\"Cluster name\",\"path\":\"cluster\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v1:Infinispan\"]},{\"description\":\"Specifies an Infinispan backup to restore.\",\"displayName\":\"Backup name\",\"path\":\"backup\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v2alpha1:Backup\"]}],\"version\":\"v2alpha1\"},{\"description\":\"Cache is the Schema for the caches API\",\"displayName\":\"Cache\",\"kind\":\"Cache\",\"name\":\"caches.infinispan.org\",\"specDescriptors\":[{\"description\":\"Infinispan cluster name\",\"displayName\":\"Cluster name\",\"path\":\"clusterName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v1:Infinispan\"]},{\"description\":\"Names the secret that contains user credentials.\",\"displayName\":\"Authentication secret\",\"path\":\"adminAuth.secretName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:Secret\"]}],\"version\":\"v2alpha1\"},{\"description\":\"Batch is the Schema for the batches API\",\"displayName\":\"Batch\",\"kind\":\"Batch\",\"name\":\"batches.infinispan.org\",\"specDescriptors\":[{\"description\":\"Infinispan cluster name\",\"displayName\":\"Cluster name\",\"path\":\"cluster\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v1:Infinispan\"]},{\"description\":\"List of commands to be executed\",\"displayName\":\"Config command\",\"path\":\"config\"},{\"description\":\"Name if the ConfigMap containing th List of commands to be executed\",\"displayName\":\"ConfigMap name\",\"path\":\"configMap\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:selector:core:v1:ConfigMap\"]}],\"statusDescriptors\":[{\"description\":\"Current state of the batch operation\",\"displayName\":\"Batch Status\",\"path\":\"phase\"},{\"description\":\"The reason for any batch related failures\",\"displayName\":\"Batch reason\",\"path\":\"reason\"}],\"version\":\"v2alpha1\"},{\"description\":\"Infinispan is the Schema for the infinispans API\",\"displayName\":\"Infinispan Cluster\",\"kind\":\"Infinispan\",\"name\":\"infinispans.infinispan.org\",\"specDescriptors\":[{\"description\":\"Controls the number of nodes in your Infinispan cluster.\",\"displayName\":\"Replicas\",\"path\":\"replicas\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:podCount\"]},{\"description\":\"Enable or disable user authentication.\",\"displayName\":\"Toggle authentication\",\"path\":\"security.endpointAuthentication\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:booleanSwitch\"]},{\"description\":\"Disable or modify endpoint encryption.\",\"displayName\":\"Configure encryption\",\"path\":\"security.endpointEncryption.type\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:select:Service\",\"urn:alm:descriptor:com.tectonic.ui:select:Secret\",\"urn:alm:descriptor:com.tectonic.ui:select:None\"]},{\"description\":\"Names the secret that contains TLS certificates.\",\"displayName\":\"Encryption secret\",\"path\":\"security.endpointEncryption.certSecretName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:Secret\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:security.endpointEncryption.type:Secret\"]},{\"description\":\"Names the service that encrypts client traffic.\",\"displayName\":\"Encryption service\",\"path\":\"security.endpointEncryption.certServiceName\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:text\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:security.endpointEncryption.type:Service\"]},{\"description\":\"Names the secret that contains user credentials.\",\"displayName\":\"Authentication secret\",\"path\":\"security.endpointSecretName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:Secret\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:security.endpointAuthentication:true\"]},{\"description\":\"Configures the service type.\",\"displayName\":\"Service type\",\"path\":\"service.type\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:select:Cache\",\"urn:alm:descriptor:com.tectonic.ui:select:DataGrid\"]},{\"description\":\"Names the access secret that allows backups to a remote site.\",\"displayName\":\"Backup location secret\",\"path\":\"service.sites.locations[].secretName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:Secret\"]},{\"description\":\"Specifies the node port that accepts traffic from a load balancer service.\",\"displayName\":\"Node port\",\"path\":\"service.sites.local.expose.nodePort\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:number\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:service.sites.local.expose.type:NodePort\"]},{\"description\":\"Controls cache replication factor, or number of copies for each entry.\",\"displayName\":\"Number of owners\",\"path\":\"service.replicationFactor\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:number\"]},{\"description\":\"Enable/disable container ephemeral storage\",\"displayName\":\"Container ephemeral storage\",\"path\":\"service.container.ephemeralStorage\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:booleanSwitch\"]},{\"description\":\"Sets the amount of storage for the persistent volume claim.\",\"displayName\":\"Storage size\",\"path\":\"service.container.storage\",\"x-descriptors\":[\"urn:alm:descriptor:text\"]},{\"description\":\"Names the storage class object for persistent volume claims.\",\"displayName\":\"Storage class name\",\"path\":\"service.container.storageClassName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:StorageClass\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:service.container.ephemeralStorage:false\"]},{\"description\":\"Defines the network hostname for your Infinispan cluster.\",\"displayName\":\"Route hostname\",\"path\":\"expose.host\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:text\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:expose.type:Route\"]},{\"description\":\"Names the PVC that holds custom libraries.\",\"displayName\":\"Persistent volume claim (PVC) name\",\"path\":\"dependencies.volumeClaimName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:PersistentVolumeClaim\"]}],\"statusDescriptors\":[{\"description\":\"The current pods\",\"displayName\":\"Pod Status\",\"path\":\"podStatus\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:podStatuses\"]},{\"description\":\"Infinispan Console location\",\"displayName\":\"Infinispan Console URL\",\"path\":\"consoleUrl\",\"x-descriptors\":[\"urn:alm:descriptor:org.w3:link\"]}],\"version\":\"v1\"}]},\"description\":\"Red Hat Data Grid is a distributed, in-memory data store built from tried and trusted open-source technology.\\n\\n### Data Grid\\n* **Schemaless structure:** Store objects in key/value pairs.\\n* **Grid storage:** Distribute and replicate data across clusters.\\n* **Elasticity:** Scale to meet workload demands without service disruption.\\n* **Polyglot access:** Read, write, and query from multiple client languages with different endpoints.\\n* **Continuous availability:** Create a fault-tolerant caching service that guarantees business continuity.\\n\\n### Operator capabilities\\n* Built-in intelligence to automate Data Grid cluster deployment.\\n* Infinispan CR for service configuration.\\n* Cache CR for fully configurable caches.\\n* Batch CR for scripting bulk resource creation.\\n* REST and Hot Rod endpoints available at port `11222`.\\n* Default application user: `developer`. Data Grid Operator generates credentials in an authentication secret at startup.\\n* Data Grid pods request `0.25` (limit `0.50`) CPUs, 512MiB of memory and 1Gi of ReadWriteOnce persistent storage. Data Grid Operator lets you adjust resource allocation to suit your requirements.\\nRed Hat Data Grid is a distributed, in-memory data store that increases application performance and delivers open-source capabilities to handle demanding use cases.\\n\",\"displayName\":\"Data Grid\",\"icon\":[{\"base64data\":\"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2Q3MWUwMDt9LmNscy0ye2ZpbGw6I2MyMWEwMDt9LmNscy0ze2ZpbGw6I2VhZWFlYTt9LmNscy00e2ZpbGw6I2ZmZjt9LmNscy01e2ZpbGw6I2I3YjdiNzt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPnByb2R1Y3RpY29uc18xMDE3X1JHQl9EYXRhR3JpZCBmaW5hbCBjb2xvcjwvdGl0bGU+PGcgaWQ9IkxheWVyXzEiIGRhdGEtbmFtZT0iTGF5ZXIgMSI+PGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI1MCIgY3k9IjUwIiByPSI1MCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIwLjcxIDUwKSByb3RhdGUoLTQ1KSIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTg1LjM2LDE0LjY0QTUwLDUwLDAsMCwxLDE0LjY0LDg1LjM2WiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTc0LjUzLDU2Ljc1QzU0LjI2LDU2LDUzLjgzLDc2LjUxLDMyLjgsNzQuMzgsMjIsNzMuMjksMTQsNjEuOSwxNi4xNyw1NC41OGw2LTE4LjU4Yy0uOTQsOC42LDEyLjM0LDIyLjU2LDIzLjExLDIzLjY1LDEyLjUyLDEuMjcsMTUuNTctNC4yOCwyOS4yLTIuOSIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTgwLjQ3LDM5LjIxQzY5LjQ3LDM4LjEsNjEuNzksNDkuMzQsNTQsNTkuNDJjNi4zNS0xLjA2LDEwLjY3LTMuNjYsMjAuNS0yLjY3aC4wNmM0Ljc2LjQ4LDQuOTUsMy41Nyw0LjczLDVsNi40Ni0xOEM4Niw0Mi4yOSw4NSwzOS42Nyw4MC40NywzOS4yMVoiLz48cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik03NC41OSw1Ni43NmgtLjA4YTIyLjM5LDIyLjM5LDAsMCwwLTE0LjM2LDQuMTYsMTcuNjEsMTcuNjEsMCwwLDAsMTAuMyw1YzMuNTIuMzYsNy43OS0xLjY4LDguODctNC4yMkM3OS41NCw2MC4zMiw3OS4zNSw1Ny4yNCw3NC41OSw1Ni43NloiLz48cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik02OC41LDQzLjA2QzYwLjY4LDM2Ljg1LDU3LjA3LDI1LDQzLjIsMjMuNjEsMjguODUsMjIuMTYsMjMuNzksMzEuNSwyMi4yOCwzNS42N2wtLjA3LjMzYy0uMjYsMi40LjU5LDUuMjMsMi4xOCw4LjA3LDMuMjEtMS43MSw3LjU3LTIuNTcsMTMuNi0yLDguMi44MywxMi44Myw4LjE5LDE4LjE0LDE0LjUzQzYwLjA2LDUxLjUzLDY0LDQ2LjQzLDY4LjUsNDMuMDZaIi8+PC9nPjwvc3ZnPg==\",\"mediatype\":\"image/svg+xml\"}],\"install\":{\"spec\":{\"clusterPermissions\":[{\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"nodes\"],\"verbs\":[\"get\",\"list\",\"watch\"]},{\"apiGroups\":[\"apiextensions.k8s.io\"],\"resources\":[\"customresourcedefinitions\",\"customresourcedefinitions/status\"],\"verbs\":[\"get\",\"list\"]},{\"apiGroups\":[\"storage.k8s.io\"],\"resources\":[\"storageclasses\"],\"verbs\":[\"get\",\"watch\"]}],\"serviceAccountName\":\"infinispan-operator\"}],\"deployments\":[{\"name\":\"infinispan-operator-new-deploy\",\"spec\":{\"replicas\":1,\"selector\":{\"matchLabels\":{\"name\":\"infinispan-operator\"}},\"strategy\":{},\"template\":{\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"}},\"spec\":{\"containers\":[{\"command\":[\"infinispan-operator\"],\"env\":[{\"name\":\"WATCH_NAMESPACE\",\"valueFrom\":{\"fieldRef\":{\"fieldPath\":\"metadata.annotations['olm.targetNamespaces']\"}}},{\"name\":\"POD_NAME\",\"valueFrom\":{\"fieldRef\":{\"fieldPath\":\"metadata.name\"}}},{\"name\":\"OPERATOR_NAME\",\"value\":\"infinispan-operator\"},{\"name\":\"RELATED_IMAGE_OPENJDK\",\"value\":\"registry.redhat.io/datagrid/datagrid-8-rhel8@sha256:34327d8d2a26a7807f5dcb7c243d31073a16981e7d125aadbb5f96bcbc9de3b1\"},{\"name\":\"RELATED_IMAGE_OPENJ9\",\"value\":\"registry.redhat.io/datagrid/datagrid-8-openj9-11-rhel8@sha256:201d872d5fa61114a09e50328bddd3f7f98368befdf8984219cf8cc75567b30a\"},{\"name\":\"INFINISPAN_OPERATOR_POD_TARGET_LABELS\",\"value\":\"{\\\"com.redhat.component-name\\\": \\\"Data_Grid\\\", \\\"com.redhat.component-type\\\": \\\"application\\\", \\\"com.redhat.component-version\\\": \\\"8.2.0\\\", \\\"com.redhat.product-name\\\": \\\"Red_Hat_Runtimes\\\", \\\"com.redhat.product-version\\\": \\\"2021-Q2\\\"}\\n\"}],\"image\":\"registry.redhat.io/datagrid/datagrid-8-rhel8-operator@sha256:d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5\",\"imagePullPolicy\":\"Always\",\"name\":\"infinispan-operator\",\"ports\":[{\"containerPort\":60000,\"name\":\"metrics\"}],\"resources\":{}}],\"serviceAccountName\":\"infinispan-operator\"}}}}],\"permissions\":[{\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"persistentvolumeclaims\",\"services\",\"services/finalizers\",\"endpoints\",\"configmaps\",\"pods\",\"secrets\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\",\"patch\"]},{\"apiGroups\":[\"\"],\"resources\":[\"pods/log\"],\"verbs\":[\"get\"]},{\"apiGroups\":[\"\"],\"resources\":[\"pods/exec\"],\"verbs\":[\"create\"]},{\"apiGroups\":[\"apps\"],\"resources\":[\"replicasets\"],\"verbs\":[\"get\"]},{\"apiGroups\":[\"apps\"],\"resources\":[\"deployments\"],\"verbs\":[\"get\",\"list\",\"watch\"]},{\"apiGroups\":[\"batch\"],\"resources\":[\"jobs\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\"]},{\"apiGroups\":[\"apps\"],\"resources\":[\"statefulsets\",\"deployments/finalizers\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\"]},{\"apiGroups\":[\"route.openshift.io\"],\"resources\":[\"routes\",\"routes/custom-host\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"delete\"]},{\"apiGroups\":[\"networking.k8s.io\"],\"resources\":[\"ingresses\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"delete\"]},{\"apiGroups\":[\"monitoring.coreos.com\"],\"resources\":[\"servicemonitors\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\"]},{\"apiGroups\":[\"infinispan.org\"],\"resources\":[\"infinispans\",\"infinispans/status\",\"infinispans/finalizers\",\"caches\",\"caches/status\",\"caches/finalizers\",\"backups\",\"backups/status\",\"backups/finalizers\",\"restores\",\"restores/status\",\"restores/finalizers\",\"batches\",\"batches/status\",\"batches/finalizers\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"patch\"]},{\"apiGroups\":[\"integreatly.org\"],\"resources\":[\"grafanadashboards\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\"]}],\"serviceAccountName\":\"infinispan-operator\"}]},\"strategy\":\"deployment\"},\"installModes\":[{\"supported\":true,\"type\":\"OwnNamespace\"},{\"supported\":true,\"type\":\"SingleNamespace\"},{\"supported\":true,\"type\":\"MultiNamespace\"},{\"supported\":true,\"type\":\"AllNamespaces\"}],\"keywords\":[\"infinispan\",\"key value\",\"database\",\"datagrid\",\"open source\"],\"labels\":{\"operated-by\":\"infinispan-operator\"},\"links\":[{\"name\":\"Blog\",\"url\":\"https://developers.redhat.com/blog/category/products/accelerated-development-management/jboss-data-grid\"},{\"name\":\"Documentation\",\"url\":\"https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.2/html-single/running_data_grid_on_openshift/\"},{\"name\":\"Operator Source Code\",\"url\":\"https://github.com/infinispan/infinispan-operator\"},{\"name\":\"Product Page\",\"url\":\"https://www.redhat.com/en/technologies/jboss-middleware/data-grid\"}],\"maintainers\":[{\"email\":\"customerservice@redhat.com\",\"name\":\"Red Hat\"}],\"maturity\":\"alpha\",\"minKubeVersion\":\"1.11.0\",\"provider\":{\"name\":\"Red Hat\"},\"relatedImages\":[{\"image\":\"registry.redhat.io/datagrid/datagrid-8-rhel8-operator@sha256:d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5\",\"name\":\"datagrid-8-rhel8-operator-d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5-annotation\"},{\"image\":\"registry.redhat.io/datagrid/datagrid-8-rhel8-operator@sha256:d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5\",\"name\":\"infinispan-operator\"},{\"image\":\"registry.redhat.io/datagrid/datagrid-8-rhel8@sha256:34327d8d2a26a7807f5dcb7c243d31073a16981e7d125aadbb5f96bcbc9de3b1\",\"name\":\"openjdk\"},{\"image\":\"registry.redhat.io/datagrid/datagrid-8-openj9-11-rhel8@sha256:201d872d5fa61114a09e50328bddd3f7f98368befdf8984219cf8cc75567b30a\",\"name\":\"openj9\"}],\"replaces\":\"datagrid-operator.v8.1.7\",\"selector\":{\"matchLabels\":{\"operated-by\":\"infinispan-operator\"}},\"version\":\"8.2.0\"}}",
  "object": [
    "{\"apiVersion\":\"operators.coreos.com/v1alpha1\",\"kind\":\"ClusterServiceVersion\",\"metadata\":{\"annotations\":{\"alm-examples\":\"[\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v1\\\",\\n    \\\"kind\\\": \\\"Infinispan\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-infinispan\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"replicas\\\": 1\\n    }\\n  },\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v2alpha1\\\",\\n    \\\"kind\\\": \\\"Backup\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-backup\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"cluster\\\": \\\"example-infinispan\\\",\\n      \\\"container\\\": {\\n        \\\"cpu\\\": \\\"1000m\\\",\\n        \\\"extraJvmOpts\\\": \\\"-Djava.property=me\\\",\\n        \\\"memory\\\": \\\"1Gi\\\"\\n      }\\n    }\\n  },\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v2alpha1\\\",\\n    \\\"kind\\\": \\\"Cache\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-cache\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"adminAuth\\\": {\\n        \\\"secretName\\\": \\\"basic-auth\\\"\\n      },\\n      \\\"clusterName\\\": \\\"example-infinispan\\\",\\n      \\\"name\\\": \\\"mycache\\\"\\n    }\\n  },\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v2alpha1\\\",\\n    \\\"kind\\\": \\\"Restore\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-restore\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"cluster\\\": \\\"example-infinispan\\\",\\n      \\\"container\\\": {\\n        \\\"cpu\\\": \\\"1000m\\\",\\n        \\\"extraJvmOpts\\\": \\\"-Djava.property=me\\\",\\n        \\\"memory\\\": \\\"1Gi\\\"\\n      }\\n    }\\n  },\\n  {\\n    \\\"apiVersion\\\": \\\"infinispan.org/v2alpha1\\\",\\n    \\\"kind\\\": \\\"Batch\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-batch\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"cluster\\\": \\\"example-infinispan\\\",\\n      \\\"config\\\": \\\"create cache --template=org.infinispan.DIST_SYNC batch-cache\\\"\\n    }\\n  }\\n]\",\"capabilities\":\"Full Lifecycle\",\"categories\":\"Database\",\"certified\":\"false\",\"containerImage\":\"registry.redhat.io/datagrid/datagrid-8-rhel8-operator@sha256:d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5\",\"createdAt\":\"2021-05-17T15:34:29Z\",\"description\":\"Create and manage Red Hat Data Grid clusters.\",\"operators.openshift.io/infrastructure-features\":\"[\\\"Disconnected\\\"]\",\"repository\":\"https://github.com/infinispan/infinispan-operator\",\"support\":\"Red Hat\"},\"labels\":{\"operatorframework.io/arch.amd64\":\"supported\",\"operatorframework.io/arch.ppc64le\":\"supported\",\"operatorframework.io/arch.s390x\":\"supported\"},\"name\":\"datagrid-operator.v8.2.0\",\"namespace\":\"placeholder\"},\"spec\":{\"apiservicedefinitions\":{},\"customresourcedefinitions\":{\"owned\":[{\"description\":\"Backup is the Schema for the backups API\",\"displayName\":\"Backup\",\"kind\":\"Backup\",\"name\":\"backups.infinispan.org\",\"specDescriptors\":[{\"description\":\"Names your Infinispan cluster.\",\"displayName\":\"Cluster name\",\"path\":\"cluster\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v1:Infinispan\"]},{\"description\":\"Names the storage class object for persistent volume claims.\",\"displayName\":\"Storage class name\",\"path\":\"volume.storageClassName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:StorageClass\"]}],\"version\":\"v2alpha1\"},{\"description\":\"Restore API schema.\",\"displayName\":\"Restore\",\"kind\":\"Restore\",\"name\":\"restores.infinispan.org\",\"specDescriptors\":[{\"description\":\"Infinispan cluster name\",\"displayName\":\"Cluster name\",\"path\":\"cluster\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v1:Infinispan\"]},{\"description\":\"Specifies an Infinispan backup to restore.\",\"displayName\":\"Backup name\",\"path\":\"backup\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v2alpha1:Backup\"]}],\"version\":\"v2alpha1\"},{\"description\":\"Cache is the Schema for the caches API\",\"displayName\":\"Cache\",\"kind\":\"Cache\",\"name\":\"caches.infinispan.org\",\"specDescriptors\":[{\"description\":\"Infinispan cluster name\",\"displayName\":\"Cluster name\",\"path\":\"clusterName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v1:Infinispan\"]},{\"description\":\"Names the secret that contains user credentials.\",\"displayName\":\"Authentication secret\",\"path\":\"adminAuth.secretName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:Secret\"]}],\"version\":\"v2alpha1\"},{\"description\":\"Batch is the Schema for the batches API\",\"displayName\":\"Batch\",\"kind\":\"Batch\",\"name\":\"batches.infinispan.org\",\"specDescriptors\":[{\"description\":\"Infinispan cluster name\",\"displayName\":\"Cluster name\",\"path\":\"cluster\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:infinispan.org:v1:Infinispan\"]},{\"description\":\"List of commands to be executed\",\"displayName\":\"Config command\",\"path\":\"config\"},{\"description\":\"Name if the ConfigMap containing th List of commands to be executed\",\"displayName\":\"ConfigMap name\",\"path\":\"configMap\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:selector:core:v1:ConfigMap\"]}],\"statusDescriptors\":[{\"description\":\"Current state of the batch operation\",\"displayName\":\"Batch Status\",\"path\":\"phase\"},{\"description\":\"The reason for any batch related failures\",\"displayName\":\"Batch reason\",\"path\":\"reason\"}],\"version\":\"v2alpha1\"},{\"description\":\"Infinispan is the Schema for the infinispans API\",\"displayName\":\"Infinispan Cluster\",\"kind\":\"Infinispan\",\"name\":\"infinispans.infinispan.org\",\"specDescriptors\":[{\"description\":\"Controls the number of nodes in your Infinispan cluster.\",\"displayName\":\"Replicas\",\"path\":\"replicas\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:podCount\"]},{\"description\":\"Enable or disable user authentication.\",\"displayName\":\"Toggle authentication\",\"path\":\"security.endpointAuthentication\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:booleanSwitch\"]},{\"description\":\"Disable or modify endpoint encryption.\",\"displayName\":\"Configure encryption\",\"path\":\"security.endpointEncryption.type\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:select:Service\",\"urn:alm:descriptor:com.tectonic.ui:select:Secret\",\"urn:alm:descriptor:com.tectonic.ui:select:None\"]},{\"description\":\"Names the secret that contains TLS certificates.\",\"displayName\":\"Encryption secret\",\"path\":\"security.endpointEncryption.certSecretName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:Secret\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:security.endpointEncryption.type:Secret\"]},{\"description\":\"Names the service that encrypts client traffic.\",\"displayName\":\"Encryption service\",\"path\":\"security.endpointEncryption.certServiceName\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:text\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:security.endpointEncryption.type:Service\"]},{\"description\":\"Names the secret that contains user credentials.\",\"displayName\":\"Authentication secret\",\"path\":\"security.endpointSecretName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:Secret\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:security.endpointAuthentication:true\"]},{\"description\":\"Configures the service type.\",\"displayName\":\"Service type\",\"path\":\"service.type\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:select:Cache\",\"urn:alm:descriptor:com.tectonic.ui:select:DataGrid\"]},{\"description\":\"Names the access secret that allows backups to a remote site.\",\"displayName\":\"Backup location secret\",\"path\":\"service.sites.locations[].secretName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:Secret\"]},{\"description\":\"Specifies the node port that accepts traffic from a load balancer service.\",\"displayName\":\"Node port\",\"path\":\"service.sites.local.expose.nodePort\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:number\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:service.sites.local.expose.type:NodePort\"]},{\"description\":\"Controls cache replication factor, or number of copies for each entry.\",\"displayName\":\"Number of owners\",\"path\":\"service.replicationFactor\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:number\"]},{\"description\":\"Enable/disable container ephemeral storage\",\"displayName\":\"Container ephemeral storage\",\"path\":\"service.container.ephemeralStorage\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:booleanSwitch\"]},{\"description\":\"Sets the amount of storage for the persistent volume claim.\",\"displayName\":\"Storage size\",\"path\":\"service.container.storage\",\"x-descriptors\":[\"urn:alm:descriptor:text\"]},{\"description\":\"Names the storage class object for persistent volume claims.\",\"displayName\":\"Storage class name\",\"path\":\"service.container.storageClassName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:StorageClass\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:service.container.ephemeralStorage:false\"]},{\"description\":\"Defines the network hostname for your Infinispan cluster.\",\"displayName\":\"Route hostname\",\"path\":\"expose.host\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:text\",\"urn:alm:descriptor:com.tectonic.ui:fieldDependency:expose.type:Route\"]},{\"description\":\"Names the PVC that holds custom libraries.\",\"displayName\":\"Persistent volume claim (PVC) name\",\"path\":\"dependencies.volumeClaimName\",\"x-descriptors\":[\"urn:alm:descriptor:io.kubernetes:PersistentVolumeClaim\"]}],\"statusDescriptors\":[{\"description\":\"The current pods\",\"displayName\":\"Pod Status\",\"path\":\"podStatus\",\"x-descriptors\":[\"urn:alm:descriptor:com.tectonic.ui:podStatuses\"]},{\"description\":\"Infinispan Console location\",\"displayName\":\"Infinispan Console URL\",\"path\":\"consoleUrl\",\"x-descriptors\":[\"urn:alm:descriptor:org.w3:link\"]}],\"version\":\"v1\"}]},\"description\":\"Red Hat Data Grid is a distributed, in-memory data store built from tried and trusted open-source technology.\\n\\n### Data Grid\\n* **Schemaless structure:** Store objects in key/value pairs.\\n* **Grid storage:** Distribute and replicate data across clusters.\\n* **Elasticity:** Scale to meet workload demands without service disruption.\\n* **Polyglot access:** Read, write, and query from multiple client languages with different endpoints.\\n* **Continuous availability:** Create a fault-tolerant caching service that guarantees business continuity.\\n\\n### Operator capabilities\\n* Built-in intelligence to automate Data Grid cluster deployment.\\n* Infinispan CR for service configuration.\\n* Cache CR for fully configurable caches.\\n* Batch CR for scripting bulk resource creation.\\n* REST and Hot Rod endpoints available at port `11222`.\\n* Default application user: `developer`. Data Grid Operator generates credentials in an authentication secret at startup.\\n* Data Grid pods request `0.25` (limit `0.50`) CPUs, 512MiB of memory and 1Gi of ReadWriteOnce persistent storage. Data Grid Operator lets you adjust resource allocation to suit your requirements.\\nRed Hat Data Grid is a distributed, in-memory data store that increases application performance and delivers open-source capabilities to handle demanding use cases.\\n\",\"displayName\":\"Data Grid\",\"icon\":[{\"base64data\":\"PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCAxMDAgMTAwIj48ZGVmcz48c3R5bGU+LmNscy0xe2ZpbGw6I2Q3MWUwMDt9LmNscy0ye2ZpbGw6I2MyMWEwMDt9LmNscy0ze2ZpbGw6I2VhZWFlYTt9LmNscy00e2ZpbGw6I2ZmZjt9LmNscy01e2ZpbGw6I2I3YjdiNzt9PC9zdHlsZT48L2RlZnM+PHRpdGxlPnByb2R1Y3RpY29uc18xMDE3X1JHQl9EYXRhR3JpZCBmaW5hbCBjb2xvcjwvdGl0bGU+PGcgaWQ9IkxheWVyXzEiIGRhdGEtbmFtZT0iTGF5ZXIgMSI+PGNpcmNsZSBjbGFzcz0iY2xzLTEiIGN4PSI1MCIgY3k9IjUwIiByPSI1MCIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIwLjcxIDUwKSByb3RhdGUoLTQ1KSIvPjxwYXRoIGNsYXNzPSJjbHMtMiIgZD0iTTg1LjM2LDE0LjY0QTUwLDUwLDAsMCwxLDE0LjY0LDg1LjM2WiIvPjxwYXRoIGNsYXNzPSJjbHMtMyIgZD0iTTc0LjUzLDU2Ljc1QzU0LjI2LDU2LDUzLjgzLDc2LjUxLDMyLjgsNzQuMzgsMjIsNzMuMjksMTQsNjEuOSwxNi4xNyw1NC41OGw2LTE4LjU4Yy0uOTQsOC42LDEyLjM0LDIyLjU2LDIzLjExLDIzLjY1LDEyLjUyLDEuMjcsMTUuNTctNC4yOCwyOS4yLTIuOSIvPjxwYXRoIGNsYXNzPSJjbHMtNCIgZD0iTTgwLjQ3LDM5LjIxQzY5LjQ3LDM4LjEsNjEuNzksNDkuMzQsNTQsNTkuNDJjNi4zNS0xLjA2LDEwLjY3LTMuNjYsMjAuNS0yLjY3aC4wNmM0Ljc2LjQ4LDQuOTUsMy41Nyw0LjczLDVsNi40Ni0xOEM4Niw0Mi4yOSw4NSwzOS42Nyw4MC40NywzOS4yMVoiLz48cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik03NC41OSw1Ni43NmgtLjA4YTIyLjM5LDIyLjM5LDAsMCwwLTE0LjM2LDQuMTYsMTcuNjEsMTcuNjEsMCwwLDAsMTAuMyw1YzMuNTIuMzYsNy43OS0xLjY4LDguODctNC4yMkM3OS41NCw2MC4zMiw3OS4zNSw1Ny4yNCw3NC41OSw1Ni43NloiLz48cGF0aCBjbGFzcz0iY2xzLTUiIGQ9Ik02OC41LDQzLjA2QzYwLjY4LDM2Ljg1LDU3LjA3LDI1LDQzLjIsMjMuNjEsMjguODUsMjIuMTYsMjMuNzksMzEuNSwyMi4yOCwzNS42N2wtLjA3LjMzYy0uMjYsMi40LjU5LDUuMjMsMi4xOCw4LjA3LDMuMjEtMS43MSw3LjU3LTIuNTcsMTMuNi0yLDguMi44MywxMi44Myw4LjE5LDE4LjE0LDE0LjUzQzYwLjA2LDUxLjUzLDY0LDQ2LjQzLDY4LjUsNDMuMDZaIi8+PC9nPjwvc3ZnPg==\",\"mediatype\":\"image/svg+xml\"}],\"install\":{\"spec\":{\"clusterPermissions\":[{\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"nodes\"],\"verbs\":[\"get\",\"list\",\"watch\"]},{\"apiGroups\":[\"apiextensions.k8s.io\"],\"resources\":[\"customresourcedefinitions\",\"customresourcedefinitions/status\"],\"verbs\":[\"get\",\"list\"]},{\"apiGroups\":[\"storage.k8s.io\"],\"resources\":[\"storageclasses\"],\"verbs\":[\"get\",\"watch\"]}],\"serviceAccountName\":\"infinispan-operator\"}],\"deployments\":[{\"name\":\"infinispan-operator-new-deploy\",\"spec\":{\"replicas\":1,\"selector\":{\"matchLabels\":{\"name\":\"infinispan-operator\"}},\"strategy\":{},\"template\":{\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"}},\"spec\":{\"containers\":[{\"command\":[\"infinispan-operator\"],\"env\":[{\"name\":\"WATCH_NAMESPACE\",\"valueFrom\":{\"fieldRef\":{\"fieldPath\":\"metadata.annotations['olm.targetNamespaces']\"}}},{\"name\":\"POD_NAME\",\"valueFrom\":{\"fieldRef\":{\"fieldPath\":\"metadata.name\"}}},{\"name\":\"OPERATOR_NAME\",\"value\":\"infinispan-operator\"},{\"name\":\"RELATED_IMAGE_OPENJDK\",\"value\":\"registry.redhat.io/datagrid/datagrid-8-rhel8@sha256:34327d8d2a26a7807f5dcb7c243d31073a16981e7d125aadbb5f96bcbc9de3b1\"},{\"name\":\"RELATED_IMAGE_OPENJ9\",\"value\":\"registry.redhat.io/datagrid/datagrid-8-openj9-11-rhel8@sha256:201d872d5fa61114a09e50328bddd3f7f98368befdf8984219cf8cc75567b30a\"},{\"name\":\"INFINISPAN_OPERATOR_POD_TARGET_LABELS\",\"value\":\"{\\\"com.redhat.component-name\\\": \\\"Data_Grid\\\", \\\"com.redhat.component-type\\\": \\\"application\\\", \\\"com.redhat.component-version\\\": \\\"8.2.0\\\", \\\"com.redhat.product-name\\\": \\\"Red_Hat_Runtimes\\\", \\\"com.redhat.product-version\\\": \\\"2021-Q2\\\"}\\n\"}],\"image\":\"registry.redhat.io/datagrid/datagrid-8-rhel8-operator@sha256:d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5\",\"imagePullPolicy\":\"Always\",\"name\":\"infinispan-operator\",\"ports\":[{\"containerPort\":60000,\"name\":\"metrics\"}],\"resources\":{}}],\"serviceAccountName\":\"infinispan-operator\"}}}}],\"permissions\":[{\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"persistentvolumeclaims\",\"services\",\"services/finalizers\",\"endpoints\",\"configmaps\",\"pods\",\"secrets\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\",\"patch\"]},{\"apiGroups\":[\"\"],\"resources\":[\"pods/log\"],\"verbs\":[\"get\"]},{\"apiGroups\":[\"\"],\"resources\":[\"pods/exec\"],\"verbs\":[\"create\"]},{\"apiGroups\":[\"apps\"],\"resources\":[\"replicasets\"],\"verbs\":[\"get\"]},{\"apiGroups\":[\"apps\"],\"resources\":[\"deployments\"],\"verbs\":[\"get\",\"list\",\"watch\"]},{\"apiGroups\":[\"batch\"],\"resources\":[\"jobs\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\"]},{\"apiGroups\":[\"apps\"],\"resources\":[\"statefulsets\",\"deployments/finalizers\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\"]},{\"apiGroups\":[\"route.openshift.io\"],\"resources\":[\"routes\",\"routes/custom-host\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"delete\"]},{\"apiGroups\":[\"networking.k8s.io\"],\"resources\":[\"ingresses\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"delete\"]},{\"apiGroups\":[\"monitoring.coreos.com\"],\"resources\":[\"servicemonitors\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\"]},{\"apiGroups\":[\"infinispan.org\"],\"resources\":[\"infinispans\",\"infinispans/status\",\"infinispans/finalizers\",\"caches\",\"caches/status\",\"caches/finalizers\",\"backups\",\"backups/status\",\"backups/finalizers\",\"restores\",\"restores/status\",\"restores/finalizers\",\"batches\",\"batches/status\",\"batches/finalizers\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"patch\"]},{\"apiGroups\":[\"integreatly.org\"],\"resources\":[\"grafanadashboards\"],\"verbs\":[\"get\",\"list\",\"watch\",\"create\",\"update\",\"delete\"]}],\"serviceAccountName\":\"infinispan-operator\"}]},\"strategy\":\"deployment\"},\"installModes\":[{\"supported\":true,\"type\":\"OwnNamespace\"},{\"supported\":true,\"type\":\"SingleNamespace\"},{\"supported\":true,\"type\":\"MultiNamespace\"},{\"supported\":true,\"type\":\"AllNamespaces\"}],\"keywords\":[\"infinispan\",\"key value\",\"database\",\"datagrid\",\"open source\"],\"labels\":{\"operated-by\":\"infinispan-operator\"},\"links\":[{\"name\":\"Blog\",\"url\":\"https://developers.redhat.com/blog/category/products/accelerated-development-management/jboss-data-grid\"},{\"name\":\"Documentation\",\"url\":\"https://access.redhat.com/documentation/en-us/red_hat_data_grid/8.2/html-single/running_data_grid_on_openshift/\"},{\"name\":\"Operator Source Code\",\"url\":\"https://github.com/infinispan/infinispan-operator\"},{\"name\":\"Product Page\",\"url\":\"https://www.redhat.com/en/technologies/jboss-middleware/data-grid\"}],\"maintainers\":[{\"email\":\"customerservice@redhat.com\",\"name\":\"Red Hat\"}],\"maturity\":\"alpha\",\"minKubeVersion\":\"1.11.0\",\"provider\":{\"name\":\"Red Hat\"},\"relatedImages\":[{\"image\":\"registry.redhat.io/datagrid/datagrid-8-rhel8-operator@sha256:d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5\",\"name\":\"datagrid-8-rhel8-operator-d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5-annotation\"},{\"image\":\"registry.redhat.io/datagrid/datagrid-8-rhel8-operator@sha256:d558eb59b63134ae8c49a028575d7fe0f78270f9f77ed41e275745bb5f2924b5\",\"name\":\"infinispan-operator\"},{\"image\":\"registry.redhat.io/datagrid/datagrid-8-rhel8@sha256:34327d8d2a26a7807f5dcb7c243d31073a16981e7d125aadbb5f96bcbc9de3b1\",\"name\":\"openjdk\"},{\"image\":\"registry.redhat.io/datagrid/datagrid-8-openj9-11-rhel8@sha256:201d872d5fa61114a09e50328bddd3f7f98368befdf8984219cf8cc75567b30a\",\"name\":\"openj9\"}],\"replaces\":\"datagrid-operator.v8.1.7\",\"selector\":{\"matchLabels\":{\"operated-by\":\"infinispan-operator\"}},\"version\":\"8.2.0\"}}",
    "{\"apiVersion\":\"apiextensions.k8s.io/v1beta1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"},\"name\":\"backups.infinispan.org\"},\"spec\":{\"group\":\"infinispan.org\",\"names\":{\"kind\":\"Backup\",\"listKind\":\"BackupList\",\"plural\":\"backups\",\"singular\":\"backup\"},\"scope\":\"Namespaced\",\"subresources\":{\"status\":{}},\"validation\":{\"openAPIV3Schema\":{\"description\":\"Backup is the Schema for the backups API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"BackupSpec defines the desired state of Backup\",\"properties\":{\"cluster\":{\"type\":\"string\"},\"container\":{\"description\":\"InfinispanContainerSpec specify resource requirements per container\",\"properties\":{\"cpu\":{\"type\":\"string\"},\"extraJvmOpts\":{\"type\":\"string\"},\"memory\":{\"type\":\"string\"}},\"type\":\"object\"},\"resources\":{\"properties\":{\"cacheConfigs\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .Templates instead.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"caches\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"counters\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"protoSchemas\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"scripts\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .Tasks instead.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"tasks\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"templates\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"volume\":{\"properties\":{\"storage\":{\"type\":\"string\"},\"storageClassName\":{\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"cluster\"],\"type\":\"object\"},\"status\":{\"description\":\"BackupStatus defines the observed state of Backup\",\"properties\":{\"phase\":{\"description\":\"State indicates the current state of the backup operation\",\"type\":\"string\"},\"pvc\":{\"description\":\"The name of the created PersistentVolumeClaim used to store the backup\",\"type\":\"string\"},\"reason\":{\"description\":\"Reason indicates the reason for any backup related failures.\",\"type\":\"string\"}},\"required\":[\"phase\"],\"type\":\"object\"}},\"type\":\"object\"}},\"version\":\"v2alpha1\",\"versions\":[{\"name\":\"v2alpha1\",\"served\":true,\"storage\":true}]}}",
    "{\"apiVersion\":\"apiextensions.k8s.io/v1beta1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"},\"name\":\"batches.infinispan.org\"},\"spec\":{\"group\":\"infinispan.org\",\"names\":{\"kind\":\"Batch\",\"listKind\":\"BatchList\",\"plural\":\"batches\",\"singular\":\"batch\"},\"scope\":\"Namespaced\",\"subresources\":{\"status\":{}},\"validation\":{\"openAPIV3Schema\":{\"description\":\"Batch is the Schema for the batches API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"BatchSpec defines the desired state of Batch\",\"properties\":{\"cluster\":{\"type\":\"string\"},\"config\":{\"type\":\"string\"},\"configMap\":{\"type\":\"string\"}},\"required\":[\"cluster\"],\"type\":\"object\"},\"status\":{\"description\":\"BatchStatus defines the observed state of Batch\",\"properties\":{\"clusterUID\":{\"description\":\"The UUID of the Infinispan instance that the Batch is associated with\",\"type\":\"string\"},\"phase\":{\"description\":\"State indicates the current state of the batch operation\",\"type\":\"string\"},\"reason\":{\"description\":\"Reason indicates the reason for any batch related failures.\",\"type\":\"string\"}},\"required\":[\"phase\"],\"type\":\"object\"}},\"type\":\"object\"}},\"version\":\"v2alpha1\",\"versions\":[{\"name\":\"v2alpha1\",\"served\":true,\"storage\":true}]}}",
    "{\"apiVersion\":\"apiextensions.k8s.io/v1beta1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"},\"name\":\"caches.infinispan.org\"},\"spec\":{\"group\":\"infinispan.org\",\"names\":{\"kind\":\"Cache\",\"listKind\":\"CacheList\",\"plural\":\"caches\",\"singular\":\"cache\"},\"scope\":\"Namespaced\",\"subresources\":{\"status\":{}},\"validation\":{\"openAPIV3Schema\":{\"description\":\"Cache is the Schema for the caches API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"CacheSpec defines the desired state of Cache\",\"properties\":{\"adminAuth\":{\"description\":\"Deprecated. This no longer has any effect. The operator's admin credentials are now used to perform cache operations\",\"properties\":{\"password\":{\"description\":\"Secret and key containing the admin password for authentication.\",\"properties\":{\"key\":{\"description\":\"The key of the secret to select from.  Must be a valid secret key.\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the Secret or its key must be defined\",\"type\":\"boolean\"}},\"required\":[\"key\"],\"type\":\"object\"},\"secretName\":{\"description\":\"name of the secret containing both admin username and password\",\"type\":\"string\"},\"username\":{\"description\":\"Secret and key containing the admin username for authentication.\",\"properties\":{\"key\":{\"description\":\"The key of the secret to select from.  Must be a valid secret key.\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the Secret or its key must be defined\",\"type\":\"boolean\"}},\"required\":[\"key\"],\"type\":\"object\"}},\"type\":\"object\"},\"clusterName\":{\"description\":\"Name of the cluster where to create the cache\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the cache to be created. If empty ObjectMeta.Name will be used\",\"type\":\"string\"},\"template\":{\"description\":\"Cache template in XML format\",\"type\":\"string\"},\"templateName\":{\"description\":\"Name of the template to be used to create this cache\",\"type\":\"string\"}},\"required\":[\"clusterName\"],\"type\":\"object\"},\"status\":{\"description\":\"CacheStatus defines the observed state of Cache\",\"properties\":{\"conditions\":{\"description\":\"Conditions list for this cache\",\"items\":{\"description\":\"CacheCondition define a condition of the cluster\",\"properties\":{\"message\":{\"description\":\"Human-readable message indicating details about last transition.\",\"type\":\"string\"},\"status\":{\"description\":\"Status is the status of the condition.\",\"type\":\"string\"},\"type\":{\"description\":\"Type is the type of the condition.\",\"type\":\"string\"}},\"required\":[\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"serviceName\":{\"description\":\"Service name that exposes the cache inside the cluster\",\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"version\":\"v2alpha1\",\"versions\":[{\"name\":\"v2alpha1\",\"served\":true,\"storage\":true}]}}",
    "{\"apiVersion\":\"apiextensions.k8s.io/v1beta1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"},\"name\":\"infinispans.infinispan.org\"},\"spec\":{\"group\":\"infinispan.org\",\"names\":{\"kind\":\"Infinispan\",\"listKind\":\"InfinispanList\",\"plural\":\"infinispans\",\"singular\":\"infinispan\"},\"scope\":\"Namespaced\",\"subresources\":{\"status\":{}},\"validation\":{\"openAPIV3Schema\":{\"description\":\"Infinispan is the Schema for the infinispans API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"InfinispanSpec defines the desired state of Infinispan\",\"properties\":{\"affinity\":{\"description\":\"Affinity is a group of affinity scheduling rules.\",\"properties\":{\"nodeAffinity\":{\"description\":\"Describes node affinity scheduling rules for the pod.\",\"properties\":{\"preferredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\\"weight\\\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.\",\"items\":{\"description\":\"An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).\",\"properties\":{\"preference\":{\"description\":\"A node selector term, associated with the corresponding weight.\",\"properties\":{\"matchExpressions\":{\"description\":\"A list of node selector requirements by node's labels.\",\"items\":{\"description\":\"A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"The label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\"type\":\"string\"},\"values\":{\"description\":\"An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchFields\":{\"description\":\"A list of node selector requirements by node's fields.\",\"items\":{\"description\":\"A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"The label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\"type\":\"string\"},\"values\":{\"description\":\"An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"weight\":{\"description\":\"Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"preference\",\"weight\"],\"type\":\"object\"},\"type\":\"array\"},\"requiredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.\",\"properties\":{\"nodeSelectorTerms\":{\"description\":\"Required. A list of node selector terms. The terms are ORed.\",\"items\":{\"description\":\"A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.\",\"properties\":{\"matchExpressions\":{\"description\":\"A list of node selector requirements by node's labels.\",\"items\":{\"description\":\"A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"The label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\"type\":\"string\"},\"values\":{\"description\":\"An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchFields\":{\"description\":\"A list of node selector requirements by node's fields.\",\"items\":{\"description\":\"A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"The label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\"type\":\"string\"},\"values\":{\"description\":\"An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"nodeSelectorTerms\"],\"type\":\"object\"}},\"type\":\"object\"},\"podAffinity\":{\"description\":\"Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).\",\"properties\":{\"preferredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\\"weight\\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.\",\"items\":{\"description\":\"The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)\",\"properties\":{\"podAffinityTerm\":{\"description\":\"Required. A pod affinity term, associated with the corresponding weight.\",\"properties\":{\"labelSelector\":{\"description\":\"A label query over a set of resources, in this case pods.\",\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaces\":{\"description\":\"namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \\\"this pod's namespace\\\"\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"topologyKey\":{\"description\":\"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\"type\":\"string\"}},\"required\":[\"topologyKey\"],\"type\":\"object\"},\"weight\":{\"description\":\"weight associated with matching the corresponding podAffinityTerm, in the range 1-100.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"podAffinityTerm\",\"weight\"],\"type\":\"object\"},\"type\":\"array\"},\"requiredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.\",\"items\":{\"description\":\"Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key \\u003ctopologyKey\\u003e matches that of any node on which a pod of the set of pods is running\",\"properties\":{\"labelSelector\":{\"description\":\"A label query over a set of resources, in this case pods.\",\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaces\":{\"description\":\"namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \\\"this pod's namespace\\\"\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"topologyKey\":{\"description\":\"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\"type\":\"string\"}},\"required\":[\"topologyKey\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"podAntiAffinity\":{\"description\":\"Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).\",\"properties\":{\"preferredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\\"weight\\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.\",\"items\":{\"description\":\"The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)\",\"properties\":{\"podAffinityTerm\":{\"description\":\"Required. A pod affinity term, associated with the corresponding weight.\",\"properties\":{\"labelSelector\":{\"description\":\"A label query over a set of resources, in this case pods.\",\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaces\":{\"description\":\"namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \\\"this pod's namespace\\\"\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"topologyKey\":{\"description\":\"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\"type\":\"string\"}},\"required\":[\"topologyKey\"],\"type\":\"object\"},\"weight\":{\"description\":\"weight associated with matching the corresponding podAffinityTerm, in the range 1-100.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"podAffinityTerm\",\"weight\"],\"type\":\"object\"},\"type\":\"array\"},\"requiredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.\",\"items\":{\"description\":\"Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key \\u003ctopologyKey\\u003e matches that of any node on which a pod of the set of pods is running\",\"properties\":{\"labelSelector\":{\"description\":\"A label query over a set of resources, in this case pods.\",\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaces\":{\"description\":\"namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \\\"this pod's namespace\\\"\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"topologyKey\":{\"description\":\"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\"type\":\"string\"}},\"required\":[\"topologyKey\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"}},\"type\":\"object\"},\"autoscale\":{\"description\":\"Autoscale describe autoscaling configuration for the cluster\",\"properties\":{\"disabled\":{\"type\":\"boolean\"},\"maxMemUsagePercent\":{\"type\":\"integer\"},\"maxReplicas\":{\"format\":\"int32\",\"type\":\"integer\"},\"minMemUsagePercent\":{\"type\":\"integer\"},\"minReplicas\":{\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"maxMemUsagePercent\",\"maxReplicas\",\"minMemUsagePercent\",\"minReplicas\"],\"type\":\"object\"},\"cloudEvents\":{\"description\":\"InfinispanCloudEvents describes how Infinispan is connected with Cloud Event, see Kafka docs for more info\",\"properties\":{\"acks\":{\"description\":\"Acks configuration for the producer ack-value\",\"type\":\"string\"},\"bootstrapServers\":{\"description\":\"BootstrapServers is comma separated list of boostrap server:port addresses\",\"type\":\"string\"},\"cacheEntriesTopic\":{\"description\":\"CacheEntriesTopic is the name of the topic on which events will be published\",\"type\":\"string\"}},\"required\":[\"bootstrapServers\"],\"type\":\"object\"},\"container\":{\"description\":\"InfinispanContainerSpec specify resource requirements per container\",\"properties\":{\"cpu\":{\"type\":\"string\"},\"extraJvmOpts\":{\"type\":\"string\"},\"memory\":{\"type\":\"string\"}},\"type\":\"object\"},\"dependencies\":{\"description\":\"External dependencies needed by the Infinispan cluster\",\"properties\":{\"volumeClaimName\":{\"description\":\"Name of the persistent volume claim with custom libraries\",\"type\":\"string\"}},\"type\":\"object\"},\"expose\":{\"description\":\"ExposeSpec describe how Infinispan will be exposed externally\",\"properties\":{\"annotations\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"host\":{\"type\":\"string\"},\"nodePort\":{\"format\":\"int32\",\"type\":\"integer\"},\"type\":{\"description\":\"Type specifies different exposition methods for data grid\",\"enum\":[\"NodePort\",\"LoadBalancer\",\"Route\"],\"type\":\"string\"}},\"required\":[\"type\"],\"type\":\"object\"},\"image\":{\"type\":\"string\"},\"logging\":{\"properties\":{\"categories\":{\"additionalProperties\":{\"description\":\"LoggingLevelType describe the logging level for selected category\",\"enum\":[\"trace\",\"debug\",\"info\",\"warn\",\"error\"],\"type\":\"string\"},\"type\":\"object\"}},\"type\":\"object\"},\"replicas\":{\"format\":\"int32\",\"type\":\"integer\"},\"security\":{\"description\":\"InfinispanSecurity info for the user application connection\",\"properties\":{\"endpointAuthentication\":{\"type\":\"boolean\"},\"endpointEncryption\":{\"description\":\"EndpointEncryption configuration\",\"properties\":{\"certSecretName\":{\"type\":\"string\"},\"certServiceName\":{\"type\":\"string\"},\"type\":{\"description\":\"CertificateSourceType specifies all the possible sources for the encryption certificate\",\"enum\":[\"Service\",\"service\",\"Secret\",\"secret\",\"None\"],\"type\":\"string\"}},\"type\":\"object\"},\"endpointSecretName\":{\"type\":\"string\"}},\"type\":\"object\"},\"service\":{\"description\":\"InfinispanServiceSpec specify configuration for specific service\",\"properties\":{\"container\":{\"description\":\"InfinispanServiceContainerSpec resource requirements specific for service\",\"properties\":{\"ephemeralStorage\":{\"type\":\"boolean\"},\"storage\":{\"type\":\"string\"},\"storageClassName\":{\"type\":\"string\"}},\"type\":\"object\"},\"replicationFactor\":{\"format\":\"int32\",\"type\":\"integer\"},\"sites\":{\"properties\":{\"local\":{\"properties\":{\"expose\":{\"description\":\"CrossSiteExposeSpec describe how Infinispan Cross-Site service will be exposed externally\",\"properties\":{\"annotations\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"nodePort\":{\"format\":\"int32\",\"type\":\"integer\"},\"type\":{\"description\":\"Type specifies different exposition methods for data grid\",\"enum\":[\"NodePort\",\"LoadBalancer\",\"ClusterIP\"],\"type\":\"string\"}},\"required\":[\"type\"],\"type\":\"object\"},\"name\":{\"type\":\"string\"}},\"required\":[\"expose\",\"name\"],\"type\":\"object\"},\"locations\":{\"items\":{\"properties\":{\"clusterName\":{\"type\":\"string\"},\"host\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .URL with infinispan+xsite schema instead.\",\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"},\"port\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .URL with infinispan+xsite schema instead.\",\"format\":\"int32\",\"type\":\"integer\"},\"secretName\":{\"type\":\"string\"},\"url\":{\"pattern\":\"(^(kubernetes|minikube|openshift):\\\\/\\\\/(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])*(:[0-9]+)+$)|(^(infinispan\\\\+xsite):\\\\/\\\\/(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])*(:[0-9]+)*$)\",\"type\":\"string\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"local\"],\"type\":\"object\"},\"type\":{\"enum\":[\"DataGrid\",\"Cache\"],\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"replicas\"],\"type\":\"object\"},\"status\":{\"description\":\"InfinispanStatus defines the observed state of Infinispan\",\"properties\":{\"conditions\":{\"items\":{\"description\":\"InfinispanCondition define a condition of the cluster\",\"properties\":{\"message\":{\"description\":\"Human-readable message indicating details about last transition.\",\"type\":\"string\"},\"status\":{\"description\":\"Status is the status of the condition.\",\"type\":\"string\"},\"type\":{\"description\":\"Type is the type of the condition.\",\"type\":\"string\"}},\"required\":[\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"consoleUrl\":{\"type\":\"string\"},\"podStatus\":{\"properties\":{\"ready\":{\"description\":\"Deployments are ready to serve requests\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"starting\":{\"description\":\"Deployments are starting, may or may not succeed\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"stopped\":{\"description\":\"Deployments are not starting, unclear what next step will be\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"replicasWantedAtRestart\":{\"format\":\"int32\",\"type\":\"integer\"},\"security\":{\"description\":\"InfinispanSecurity info for the user application connection\",\"properties\":{\"endpointAuthentication\":{\"type\":\"boolean\"},\"endpointEncryption\":{\"description\":\"EndpointEncryption configuration\",\"properties\":{\"certSecretName\":{\"type\":\"string\"},\"certServiceName\":{\"type\":\"string\"},\"type\":{\"description\":\"CertificateSourceType specifies all the possible sources for the encryption certificate\",\"enum\":[\"Service\",\"service\",\"Secret\",\"secret\",\"None\"],\"type\":\"string\"}},\"type\":\"object\"},\"endpointSecretName\":{\"type\":\"string\"}},\"type\":\"object\"},\"statefulSetName\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"version\":\"v1\",\"versions\":[{\"name\":\"v1\",\"served\":true,\"storage\":true}]}}",
    "{\"apiVersion\":\"apiextensions.k8s.io/v1beta1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"},\"name\":\"restores.infinispan.org\"},\"spec\":{\"group\":\"infinispan.org\",\"names\":{\"kind\":\"Restore\",\"listKind\":\"RestoreList\",\"plural\":\"restores\",\"singular\":\"restore\"},\"scope\":\"Namespaced\",\"subresources\":{\"status\":{}},\"validation\":{\"openAPIV3Schema\":{\"description\":\"Restore is the Schema for the restores API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"BackupSpec defines the desired state of Backup\",\"properties\":{\"backup\":{\"type\":\"string\"},\"cluster\":{\"type\":\"string\"},\"container\":{\"description\":\"InfinispanContainerSpec specify resource requirements per container\",\"properties\":{\"cpu\":{\"type\":\"string\"},\"extraJvmOpts\":{\"type\":\"string\"},\"memory\":{\"type\":\"string\"}},\"type\":\"object\"},\"resources\":{\"properties\":{\"cacheConfigs\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .Templates instead.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"caches\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"counters\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"protoSchemas\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"scripts\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .Tasks instead.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"tasks\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"templates\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"}},\"required\":[\"backup\",\"cluster\"],\"type\":\"object\"},\"status\":{\"description\":\"RestoreStatus defines the observed state of Restore\",\"properties\":{\"phase\":{\"description\":\"State indicates the current state of the restore operation\",\"type\":\"string\"},\"reason\":{\"description\":\"Reason indicates the reason for any Restore related failures.\",\"type\":\"string\"}},\"required\":[\"phase\"],\"type\":\"object\"}},\"type\":\"object\"}},\"version\":\"v2alpha1\",\"versions\":[{\"name\":\"v2alpha1\",\"served\":true,\"storage\":true}]}}",
    "{\"apiVersion\":\"apiextensions.k8s.io/v1beta1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"},\"name\":\"caches.infinispan.org\"},\"spec\":{\"group\":\"infinispan.org\",\"names\":{\"kind\":\"Cache\",\"listKind\":\"CacheList\",\"plural\":\"caches\",\"singular\":\"cache\"},\"scope\":\"Namespaced\",\"subresources\":{\"status\":{}},\"validation\":{\"openAPIV3Schema\":{\"description\":\"Cache is the Schema for the caches API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"CacheSpec defines the desired state of Cache\",\"properties\":{\"adminAuth\":{\"description\":\"Deprecated. This no longer has any effect. The operator's admin credentials are now used to perform cache operations\",\"properties\":{\"password\":{\"description\":\"Secret and key containing the admin password for authentication.\",\"properties\":{\"key\":{\"description\":\"The key of the secret to select from.  Must be a valid secret key.\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the Secret or its key must be defined\",\"type\":\"boolean\"}},\"required\":[\"key\"],\"type\":\"object\"},\"secretName\":{\"description\":\"name of the secret containing both admin username and password\",\"type\":\"string\"},\"username\":{\"description\":\"Secret and key containing the admin username for authentication.\",\"properties\":{\"key\":{\"description\":\"The key of the secret to select from.  Must be a valid secret key.\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names TODO: Add other useful fields. apiVersion, kind, uid?\",\"type\":\"string\"},\"optional\":{\"description\":\"Specify whether the Secret or its key must be defined\",\"type\":\"boolean\"}},\"required\":[\"key\"],\"type\":\"object\"}},\"type\":\"object\"},\"clusterName\":{\"description\":\"Name of the cluster where to create the cache\",\"type\":\"string\"},\"name\":{\"description\":\"Name of the cache to be created. If empty ObjectMeta.Name will be used\",\"type\":\"string\"},\"template\":{\"description\":\"Cache template in XML format\",\"type\":\"string\"},\"templateName\":{\"description\":\"Name of the template to be used to create this cache\",\"type\":\"string\"}},\"required\":[\"clusterName\"],\"type\":\"object\"},\"status\":{\"description\":\"CacheStatus defines the observed state of Cache\",\"properties\":{\"conditions\":{\"description\":\"Conditions list for this cache\",\"items\":{\"description\":\"CacheCondition define a condition of the cluster\",\"properties\":{\"message\":{\"description\":\"Human-readable message indicating details about last transition.\",\"type\":\"string\"},\"status\":{\"description\":\"Status is the status of the condition.\",\"type\":\"string\"},\"type\":{\"description\":\"Type is the type of the condition.\",\"type\":\"string\"}},\"required\":[\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"serviceName\":{\"description\":\"Service name that exposes the cache inside the cluster\",\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"version\":\"v2alpha1\",\"versions\":[{\"name\":\"v2alpha1\",\"served\":true,\"storage\":true}]}}",
    "{\"apiVersion\":\"apiextensions.k8s.io/v1beta1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"},\"name\":\"infinispans.infinispan.org\"},\"spec\":{\"group\":\"infinispan.org\",\"names\":{\"kind\":\"Infinispan\",\"listKind\":\"InfinispanList\",\"plural\":\"infinispans\",\"singular\":\"infinispan\"},\"scope\":\"Namespaced\",\"subresources\":{\"status\":{}},\"validation\":{\"openAPIV3Schema\":{\"description\":\"Infinispan is the Schema for the infinispans API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"InfinispanSpec defines the desired state of Infinispan\",\"properties\":{\"affinity\":{\"description\":\"Affinity is a group of affinity scheduling rules.\",\"properties\":{\"nodeAffinity\":{\"description\":\"Describes node affinity scheduling rules for the pod.\",\"properties\":{\"preferredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\\"weight\\\" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.\",\"items\":{\"description\":\"An empty preferred scheduling term matches all objects with implicit weight 0 (i.e. it's a no-op). A null preferred scheduling term matches no objects (i.e. is also a no-op).\",\"properties\":{\"preference\":{\"description\":\"A node selector term, associated with the corresponding weight.\",\"properties\":{\"matchExpressions\":{\"description\":\"A list of node selector requirements by node's labels.\",\"items\":{\"description\":\"A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"The label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\"type\":\"string\"},\"values\":{\"description\":\"An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchFields\":{\"description\":\"A list of node selector requirements by node's fields.\",\"items\":{\"description\":\"A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"The label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\"type\":\"string\"},\"values\":{\"description\":\"An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"weight\":{\"description\":\"Weight associated with matching the corresponding nodeSelectorTerm, in the range 1-100.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"preference\",\"weight\"],\"type\":\"object\"},\"type\":\"array\"},\"requiredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.\",\"properties\":{\"nodeSelectorTerms\":{\"description\":\"Required. A list of node selector terms. The terms are ORed.\",\"items\":{\"description\":\"A null or empty node selector term matches no objects. The requirements of them are ANDed. The TopologySelectorTerm type implements a subset of the NodeSelectorTerm.\",\"properties\":{\"matchExpressions\":{\"description\":\"A list of node selector requirements by node's labels.\",\"items\":{\"description\":\"A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"The label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\"type\":\"string\"},\"values\":{\"description\":\"An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchFields\":{\"description\":\"A list of node selector requirements by node's fields.\",\"items\":{\"description\":\"A node selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"The label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"Represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists, DoesNotExist. Gt, and Lt.\",\"type\":\"string\"},\"values\":{\"description\":\"An array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. If the operator is Gt or Lt, the values array must have a single element, which will be interpreted as an integer. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"nodeSelectorTerms\"],\"type\":\"object\"}},\"type\":\"object\"},\"podAffinity\":{\"description\":\"Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).\",\"properties\":{\"preferredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\\"weight\\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.\",\"items\":{\"description\":\"The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)\",\"properties\":{\"podAffinityTerm\":{\"description\":\"Required. A pod affinity term, associated with the corresponding weight.\",\"properties\":{\"labelSelector\":{\"description\":\"A label query over a set of resources, in this case pods.\",\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaces\":{\"description\":\"namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \\\"this pod's namespace\\\"\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"topologyKey\":{\"description\":\"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\"type\":\"string\"}},\"required\":[\"topologyKey\"],\"type\":\"object\"},\"weight\":{\"description\":\"weight associated with matching the corresponding podAffinityTerm, in the range 1-100.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"podAffinityTerm\",\"weight\"],\"type\":\"object\"},\"type\":\"array\"},\"requiredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.\",\"items\":{\"description\":\"Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key \\u003ctopologyKey\\u003e matches that of any node on which a pod of the set of pods is running\",\"properties\":{\"labelSelector\":{\"description\":\"A label query over a set of resources, in this case pods.\",\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaces\":{\"description\":\"namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \\\"this pod's namespace\\\"\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"topologyKey\":{\"description\":\"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\"type\":\"string\"}},\"required\":[\"topologyKey\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"},\"podAntiAffinity\":{\"description\":\"Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).\",\"properties\":{\"preferredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding \\\"weight\\\" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.\",\"items\":{\"description\":\"The weights of all of the matched WeightedPodAffinityTerm fields are added per-node to find the most preferred node(s)\",\"properties\":{\"podAffinityTerm\":{\"description\":\"Required. A pod affinity term, associated with the corresponding weight.\",\"properties\":{\"labelSelector\":{\"description\":\"A label query over a set of resources, in this case pods.\",\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaces\":{\"description\":\"namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \\\"this pod's namespace\\\"\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"topologyKey\":{\"description\":\"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\"type\":\"string\"}},\"required\":[\"topologyKey\"],\"type\":\"object\"},\"weight\":{\"description\":\"weight associated with matching the corresponding podAffinityTerm, in the range 1-100.\",\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"podAffinityTerm\",\"weight\"],\"type\":\"object\"},\"type\":\"array\"},\"requiredDuringSchedulingIgnoredDuringExecution\":{\"description\":\"If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.\",\"items\":{\"description\":\"Defines a set of pods (namely those matching the labelSelector relative to the given namespace(s)) that this pod should be co-located (affinity) or not co-located (anti-affinity) with, where co-located is defined as running on a node whose value of the label with key \\u003ctopologyKey\\u003e matches that of any node on which a pod of the set of pods is running\",\"properties\":{\"labelSelector\":{\"description\":\"A label query over a set of resources, in this case pods.\",\"properties\":{\"matchExpressions\":{\"description\":\"matchExpressions is a list of label selector requirements. The requirements are ANDed.\",\"items\":{\"description\":\"A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.\",\"properties\":{\"key\":{\"description\":\"key is the label key that the selector applies to.\",\"type\":\"string\"},\"operator\":{\"description\":\"operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.\",\"type\":\"string\"},\"values\":{\"description\":\"values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"required\":[\"key\",\"operator\"],\"type\":\"object\"},\"type\":\"array\"},\"matchLabels\":{\"additionalProperties\":{\"type\":\"string\"},\"description\":\"matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is \\\"key\\\", the operator is \\\"In\\\", and the values array contains only \\\"value\\\". The requirements are ANDed.\",\"type\":\"object\"}},\"type\":\"object\"},\"namespaces\":{\"description\":\"namespaces specifies which namespaces the labelSelector applies to (matches against); null or empty list means \\\"this pod's namespace\\\"\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"topologyKey\":{\"description\":\"This pod should be co-located (affinity) or not co-located (anti-affinity) with the pods matching the labelSelector in the specified namespaces, where co-located is defined as running on a node whose value of the label with key topologyKey matches that of any node on which any of the selected pods is running. Empty topologyKey is not allowed.\",\"type\":\"string\"}},\"required\":[\"topologyKey\"],\"type\":\"object\"},\"type\":\"array\"}},\"type\":\"object\"}},\"type\":\"object\"},\"autoscale\":{\"description\":\"Autoscale describe autoscaling configuration for the cluster\",\"properties\":{\"disabled\":{\"type\":\"boolean\"},\"maxMemUsagePercent\":{\"type\":\"integer\"},\"maxReplicas\":{\"format\":\"int32\",\"type\":\"integer\"},\"minMemUsagePercent\":{\"type\":\"integer\"},\"minReplicas\":{\"format\":\"int32\",\"type\":\"integer\"}},\"required\":[\"maxMemUsagePercent\",\"maxReplicas\",\"minMemUsagePercent\",\"minReplicas\"],\"type\":\"object\"},\"cloudEvents\":{\"description\":\"InfinispanCloudEvents describes how Infinispan is connected with Cloud Event, see Kafka docs for more info\",\"properties\":{\"acks\":{\"description\":\"Acks configuration for the producer ack-value\",\"type\":\"string\"},\"bootstrapServers\":{\"description\":\"BootstrapServers is comma separated list of boostrap server:port addresses\",\"type\":\"string\"},\"cacheEntriesTopic\":{\"description\":\"CacheEntriesTopic is the name of the topic on which events will be published\",\"type\":\"string\"}},\"required\":[\"bootstrapServers\"],\"type\":\"object\"},\"container\":{\"description\":\"InfinispanContainerSpec specify resource requirements per container\",\"properties\":{\"cpu\":{\"type\":\"string\"},\"extraJvmOpts\":{\"type\":\"string\"},\"memory\":{\"type\":\"string\"}},\"type\":\"object\"},\"dependencies\":{\"description\":\"External dependencies needed by the Infinispan cluster\",\"properties\":{\"volumeClaimName\":{\"description\":\"Name of the persistent volume claim with custom libraries\",\"type\":\"string\"}},\"type\":\"object\"},\"expose\":{\"description\":\"ExposeSpec describe how Infinispan will be exposed externally\",\"properties\":{\"annotations\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"host\":{\"type\":\"string\"},\"nodePort\":{\"format\":\"int32\",\"type\":\"integer\"},\"type\":{\"description\":\"Type specifies different exposition methods for data grid\",\"enum\":[\"NodePort\",\"LoadBalancer\",\"Route\"],\"type\":\"string\"}},\"required\":[\"type\"],\"type\":\"object\"},\"image\":{\"type\":\"string\"},\"logging\":{\"properties\":{\"categories\":{\"additionalProperties\":{\"description\":\"LoggingLevelType describe the logging level for selected category\",\"enum\":[\"trace\",\"debug\",\"info\",\"warn\",\"error\"],\"type\":\"string\"},\"type\":\"object\"}},\"type\":\"object\"},\"replicas\":{\"format\":\"int32\",\"type\":\"integer\"},\"security\":{\"description\":\"InfinispanSecurity info for the user application connection\",\"properties\":{\"endpointAuthentication\":{\"type\":\"boolean\"},\"endpointEncryption\":{\"description\":\"EndpointEncryption configuration\",\"properties\":{\"certSecretName\":{\"type\":\"string\"},\"certServiceName\":{\"type\":\"string\"},\"type\":{\"description\":\"CertificateSourceType specifies all the possible sources for the encryption certificate\",\"enum\":[\"Service\",\"service\",\"Secret\",\"secret\",\"None\"],\"type\":\"string\"}},\"type\":\"object\"},\"endpointSecretName\":{\"type\":\"string\"}},\"type\":\"object\"},\"service\":{\"description\":\"InfinispanServiceSpec specify configuration for specific service\",\"properties\":{\"container\":{\"description\":\"InfinispanServiceContainerSpec resource requirements specific for service\",\"properties\":{\"ephemeralStorage\":{\"type\":\"boolean\"},\"storage\":{\"type\":\"string\"},\"storageClassName\":{\"type\":\"string\"}},\"type\":\"object\"},\"replicationFactor\":{\"format\":\"int32\",\"type\":\"integer\"},\"sites\":{\"properties\":{\"local\":{\"properties\":{\"expose\":{\"description\":\"CrossSiteExposeSpec describe how Infinispan Cross-Site service will be exposed externally\",\"properties\":{\"annotations\":{\"additionalProperties\":{\"type\":\"string\"},\"type\":\"object\"},\"nodePort\":{\"format\":\"int32\",\"type\":\"integer\"},\"type\":{\"description\":\"Type specifies different exposition methods for data grid\",\"enum\":[\"NodePort\",\"LoadBalancer\",\"ClusterIP\"],\"type\":\"string\"}},\"required\":[\"type\"],\"type\":\"object\"},\"name\":{\"type\":\"string\"}},\"required\":[\"expose\",\"name\"],\"type\":\"object\"},\"locations\":{\"items\":{\"properties\":{\"clusterName\":{\"type\":\"string\"},\"host\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .URL with infinispan+xsite schema instead.\",\"type\":\"string\"},\"name\":{\"type\":\"string\"},\"namespace\":{\"type\":\"string\"},\"port\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .URL with infinispan+xsite schema instead.\",\"format\":\"int32\",\"type\":\"integer\"},\"secretName\":{\"type\":\"string\"},\"url\":{\"pattern\":\"(^(kubernetes|minikube|openshift):\\\\/\\\\/(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])*(:[0-9]+)+$)|(^(infinispan\\\\+xsite):\\\\/\\\\/(([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])\\\\.)*([a-z0-9]|[a-z0-9][a-z0-9\\\\-]*[a-z0-9])*(:[0-9]+)*$)\",\"type\":\"string\"}},\"required\":[\"name\"],\"type\":\"object\"},\"type\":\"array\"}},\"required\":[\"local\"],\"type\":\"object\"},\"type\":{\"enum\":[\"DataGrid\",\"Cache\"],\"type\":\"string\"}},\"type\":\"object\"}},\"required\":[\"replicas\"],\"type\":\"object\"},\"status\":{\"description\":\"InfinispanStatus defines the observed state of Infinispan\",\"properties\":{\"conditions\":{\"items\":{\"description\":\"InfinispanCondition define a condition of the cluster\",\"properties\":{\"message\":{\"description\":\"Human-readable message indicating details about last transition.\",\"type\":\"string\"},\"status\":{\"description\":\"Status is the status of the condition.\",\"type\":\"string\"},\"type\":{\"description\":\"Type is the type of the condition.\",\"type\":\"string\"}},\"required\":[\"status\",\"type\"],\"type\":\"object\"},\"type\":\"array\"},\"consoleUrl\":{\"type\":\"string\"},\"podStatus\":{\"properties\":{\"ready\":{\"description\":\"Deployments are ready to serve requests\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"starting\":{\"description\":\"Deployments are starting, may or may not succeed\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"stopped\":{\"description\":\"Deployments are not starting, unclear what next step will be\",\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"},\"replicasWantedAtRestart\":{\"format\":\"int32\",\"type\":\"integer\"},\"security\":{\"description\":\"InfinispanSecurity info for the user application connection\",\"properties\":{\"endpointAuthentication\":{\"type\":\"boolean\"},\"endpointEncryption\":{\"description\":\"EndpointEncryption configuration\",\"properties\":{\"certSecretName\":{\"type\":\"string\"},\"certServiceName\":{\"type\":\"string\"},\"type\":{\"description\":\"CertificateSourceType specifies all the possible sources for the encryption certificate\",\"enum\":[\"Service\",\"service\",\"Secret\",\"secret\",\"None\"],\"type\":\"string\"}},\"type\":\"object\"},\"endpointSecretName\":{\"type\":\"string\"}},\"type\":\"object\"},\"statefulSetName\":{\"type\":\"string\"}},\"type\":\"object\"}},\"type\":\"object\"}},\"version\":\"v1\",\"versions\":[{\"name\":\"v1\",\"served\":true,\"storage\":true}]}}",
    "{\"apiVersion\":\"apiextensions.k8s.io/v1beta1\",\"kind\":\"CustomResourceDefinition\",\"metadata\":{\"labels\":{\"name\":\"infinispan-operator\"},\"name\":\"restores.infinispan.org\"},\"spec\":{\"group\":\"infinispan.org\",\"names\":{\"kind\":\"Restore\",\"listKind\":\"RestoreList\",\"plural\":\"restores\",\"singular\":\"restore\"},\"scope\":\"Namespaced\",\"subresources\":{\"status\":{}},\"validation\":{\"openAPIV3Schema\":{\"description\":\"Restore is the Schema for the restores API\",\"properties\":{\"apiVersion\":{\"description\":\"APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources\",\"type\":\"string\"},\"kind\":{\"description\":\"Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds\",\"type\":\"string\"},\"metadata\":{\"type\":\"object\"},\"spec\":{\"description\":\"BackupSpec defines the desired state of Backup\",\"properties\":{\"backup\":{\"type\":\"string\"},\"cluster\":{\"type\":\"string\"},\"container\":{\"description\":\"InfinispanContainerSpec specify resource requirements per container\",\"properties\":{\"cpu\":{\"type\":\"string\"},\"extraJvmOpts\":{\"type\":\"string\"},\"memory\":{\"type\":\"string\"}},\"type\":\"object\"},\"resources\":{\"properties\":{\"cacheConfigs\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .Templates instead.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"caches\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"counters\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"protoSchemas\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"scripts\":{\"description\":\"Deprecated and to be removed on subsequent release. Use .Tasks instead.\",\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"tasks\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"},\"templates\":{\"items\":{\"type\":\"string\"},\"type\":\"array\"}},\"type\":\"object\"}},\"required\":[\"backup\",\"cluster\"],\"type\":\"object\"},\"status\":{\"description\":\"RestoreStatus defines the observed state of Restore\",\"properties\":{\"phase\":{\"description\":\"State indicates the current state of the restore operation\",\"type\":\"string\"},\"reason\":{\"description\":\"Reason indicates the reason for any Restore related failures.\",\"type\":\"string\"}},\"required\":[\"phase\"],\"type\":\"object\"}},\"type\":\"object\"}},\"version\":\"v2alpha1\",\"versions\":[{\"name\":\"v2alpha1\",\"served\":true,\"storage\":true}]}}"
  ],
  "spec": "{\"apiVersion\":\"operators.coreos.com/v1alpha1\",\"kind\":\"ClusterServiceVersion\",\"metadata\":{\"annotations\":{\"alm-examples\":\"[\\n  {\\n    \\\"apiVersion\\\": \\\"submariner.io/v1alpha1\\\",\\n    \\\"kind\\\": \\\"Submariner\\\",\\n    \\\"metadata\\\": {\\n      \\\"name\\\": \\\"example-submariner\\\"\\n    },\\n    \\\"spec\\\": {\\n      \\\"broker\\\": \\\"k8s\\\",\\n      \\\"brokerK8sApiServer\\\": \\\"192.168.67.110:8443\\\",\\n      \\\"brokerK8sApiServerToken\\\": \\\"$(SECRET_API_SERVER_TOKEN)\\\",\\n      \\\"brokerK8sCA\\\": \\\"$(SECRET_CA)\\\",\\n      \\\"brokerK8sRemoteNamespace\\\": \\\"submariner-broker\\\",\\n      \\\"cableDriver\\\": \\\"libreswan\\\",\\n      \\\"ceIPSecDebug\\\": false,\\n      \\\"ceIPSecIKEPort\\\": 500,\\n      \\\"ceIPSecNATTPort\\\": 4500,\\n      \\\"ceIPSecPSK\\\": \\\"$(SECRET_IPSEC_PSK)\\\",\\n      \\\"clusterCIDR\\\": \\\"192.168.67.0/24\\\",\\n      \\\"clusterID\\\": \\\"east\\\",\\n      \\\"colorCodes\\\": \\\"blue\\\",\\n      \\\"debug\\\": false,\\n      \\\"globalCIDR\\\": \\\"169.254.0.0/16\\\",\\n      \\\"namespace\\\": \\\"submariner_operator\\\",\\n      \\\"natEnabled\\\": true,\\n      \\\"serviceCIDR\\\": \\\"192.168.66.0/24\\\",\\n      \\\"serviceDiscoveryEnabled\\\": true\\n    }\\n  }\\n]\",\"capabilities\":\"Basic Install\",\"categories\":\"Networking\",\"certified\":\"false\",\"containerImage\":\"registry.redhat.io/rhacm2-tech-preview/submariner-rhel8-operator@sha256:3bf59d5e45e4d01e92e96073d7234d6e6b535a5e7b4d41c352076a6ea50012c7\",\"createdAt\":\"2021-02-11 17:38:17\",\"description\":\"Creates and manages Submariner deployments.\",\"operators.operatorframework.io/builder\":\"operator-sdk-v1.0.1\",\"operators.operatorframework.io/project_layout\":\"go.kubebuilder.io/v2\",\"repository\":\"https://github.com/submariner-io/submariner-operator\",\"support\":\"Red Hat\"},\"name\":\"submariner.v0.8.1\",\"namespace\":\"placeholder\"},\"spec\":{\"apiservicedefinitions\":{},\"customresourcedefinitions\":{\"owned\":[{\"description\":\"Submariner is the Schema for the submariners API\",\"displayName\":\"Submariner\",\"kind\":\"Submariner\",\"name\":\"submariners.submariner.io\",\"version\":\"v1alpha1\"}]},\"description\":\"[Submariner](https://submariner-io) enables direct networking between Pods and Services in different Kubernetes\\nclusters. With Submariner, your applications and services can span multiple cloud providers, data centers, and regions.\\n\\nSubmariner is designed to be cloud provider and network plugin (CNI) agnostic.\\n\\nSubmariner consists of several main components that work in conjunction to securely connect workloads across\\nmultiple Kubernetes clusters, both on-premise and on public clouds:\\n* [Gateway Engine](https://submariner.io/architecture/gateway-engine/): manages the secure tunnels to other clusters.\\n* [Route Agent](https://submariner.io/architecture/route-agent/): routes cross-cluster traffic from nodes\\nto the active Gateway Engine.\\n* [Broker](https://submariner.io/architecture/broker/): facilitates the exchange of metadata between Gateway\\nEngines enabling them to discover one another.\\n\\nSubmariner has optional components that provide additional functionality:\\n* [Globalnet Controller](https://submariner.io/architecture/globalnet/): handles overlapping CIDRs across clusters.\\n* [Service Discovery](https://submariner.io/architecture/service-discovery/): provides DNS discovery of services\\nacross clusters.\\n\\n### Prerequisites\\nSubmariner has a few requirements to get started, all are documented [here](https://submariner.io/quickstart/#prerequisites).\\n\\n### Deployment\\nSubmariner provides an [Operator](https://github.com/submariner-io/submariner-operator) for easy API-based\\ninstallation and management.\\nA command line utility, [subctl](https://github.com/submariner-io/submariner-operator/releases), wraps the\\nOperator to aid users with manual deployments and easy experimentation.\\nsubctl greatly simplifies the deployment of Submariner, and is therefore the recommended deployment method.\\nFor complete information about subctl, please refer to [this page](https://submariner.io/deployment/subctl).\\nIn addition to Operator and subctl, Submariner also provides [Helm Charts](https://submariner.io/deployment/helm).\\n\\n#### Deploying with subctl\\nInstall the tool:\\n```bash\\ncurl -Ls https://get.submariner.io | bash\\nexport PATH=$PATH:~/.local/bin\\necho export PATH=\\\\$PATH:~/.local/bin \\u003e\\u003e ~/.profile\\n```\\nDeploy the broker:\\n\\n`subctl deploy-broker --kubeconfig \\u003cPATH-TO-KUBECONFIG-BROKER\\u003e`\\n\\nFor each cluster you want to join, issue the following command:\\n\\n`subctl join --kubeconfig \\u003cPATH-TO-JOINING-CLUSTER\\u003e broker-info.subm --clusterid \\u003cID\\u003e`\\n\\nMore information can be found [here](https://submariner.io/deployment/subctl).\\n\\nSubmariner is deployed using the Submariner CR. The following values can be specified:\\n* **namespace**: the namespace to install in;\\n* **serviceCIDR**: the service CIDR;\\n* **clusterCIDR**: the cluster CIDR;\\n* **token**: the Submariner token\\n    to retrieve the token run the following command on the broker cluster, assuming the broker is running in the\\n    *submariner* namespace replace the two *submariner* instances as appropriate\\n\\n    `kubectl -n submariner get secrets -o\\n    jsonpath=\\\"{.items[?(@.metadata.annotations['kubernetes.io/service-account.name']=='submariner-client')].data.token}\\\"\\n    | base64 --decode`\\n\\n* **clusterID**: the Submariner cluster ID;\\n* **colorCodes**: the Submariner color code(s) for this cluster;\\n* **debug**: *'true'* to enable logging debugging information;\\n* **natEnabled**: *'true'* if there is NAT between clusters. Typically *'true'* in public cloud or mixed on-prem/public cloud environments and *'false'* when all clusters are on-prem.\\n* **broker**: this must be *k8s* currently;\\n* **brokerK8sApiServer**: the broker API server URL\\n    to retrieve it run the following command on the broker cluster\\n\\n    `kubectl -n default get endpoints kubernetes -o\\n    jsonpath=\\\"{.subsets[0].addresses[0].ip}:{.subsets[0].ports[?(@.name=='https')].port}\\\"`\\n\\n* **brokerK8sApiServerToken**: the broker API server token (same as *submariner_token*);\\n* **brokerK8sRemoteNamespace**: the broker namespace;\\n* **brokerK8sCA**: the broker certificate authority\\n    to retrieve the broker CA run the following command on the broker cluster, assuming the broker is running in\\n    the *submariner* namespace replace the two *submariner* instances as appropriate\\n\\n    `kubectl -n submariner get secrets -o\\n    jsonpath=\\\"{.items[?(@.metadata.annotations['kubernetes.io/service-account.name']=='submariner-client')].data['ca.crt']}\\\"`\\n\\n* **ceIPSecPSK**: the IPsec PSK (which must be identical in all route agents across the cluster);\\n* **ceIPSecDebug**: *'true'* to enable logging IPsec debugging information (from the IPsec daemon);\\n* **ceIPSecIKEPort**: the IPsec IKE port (500 usually);\\n* **ceIPSecNATTPort**: the IPsec NAT traversal port (4500 usually);\\n* **repository**: the container repository to use.\\n* **version**: the container version to use.\\n* **imageOverrides**: A string map that overrides the images by defining a path for each component.\\n                      This field is meant to be used by CI, development or testing.\\n\\n  **example:**\\n\\n  ```yaml\\n  imageOverrides:\\n    submariner-route-agent=my_repo/my_custom_image:my_tag\\n    submariner-globalnet=my_repo/my_custom_image:my_tag\\n  ```\\n\",\"displayName\":\"Submariner\",\"icon\":[{\"base64data\":\"PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+CjxzdmcKICAgeG1sbnM6ZGM9Imh0dHA6Ly9wdXJsLm9yZy9kYy9lbGVtZW50cy8xLjEvIgogICB4bWxuczpjYz0iaHR0cDovL2NyZWF0aXZlY29tbW9ucy5vcmcvbnMjIgogICB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiCiAgIHhtbG5zOnN2Zz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciCiAgIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgdmlld0JveD0iMCAwIDE4NS40OTg5NiAxODUuNDk4OTQiCiAgIHZlcnNpb249IjEuMSIKICAgaWQ9InN2ZzQ2NTYiCiAgIHNvZGlwb2RpOmRvY25hbWU9ImxvZ28uc3ZnIgogICB3aWR0aD0iMTg1LjQ5ODk2IgogICBoZWlnaHQ9IjE4NS40OTg5NSIKICAgaW5rc2NhcGU6dmVyc2lvbj0iMC45Mi40ICh1bmtub3duKSI+CiAgPG1ldGFkYXRhCiAgICAgaWQ9Im1ldGFkYXRhNDY2MCI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGU+bG9nbzwvZGM6dGl0bGU+CiAgICAgIDwvY2M6V29yaz4KICAgIDwvcmRmOlJERj4KICA8L21ldGFkYXRhPgogIDxzb2RpcG9kaTpuYW1lZHZpZXcKICAgICBwYWdlY29sb3I9IiNmZmZmZmYiCiAgICAgYm9yZGVyY29sb3I9IiM2NjY2NjYiCiAgICAgYm9yZGVyb3BhY2l0eT0iMSIKICAgICBvYmplY3R0b2xlcmFuY2U9IjEwIgogICAgIGdyaWR0b2xlcmFuY2U9IjEwIgogICAgIGd1aWRldG9sZXJhbmNlPSIxMCIKICAgICBpbmtzY2FwZTpwYWdlb3BhY2l0eT0iMCIKICAgICBpbmtzY2FwZTpwYWdlc2hhZG93PSIyIgogICAgIGlua3NjYXBlOndpbmRvdy13aWR0aD0iMTkyMCIKICAgICBpbmtzY2FwZTp3aW5kb3ctaGVpZ2h0PSIxMDE2IgogICAgIGlkPSJuYW1lZHZpZXc0NjU4IgogICAgIHNob3dncmlkPSJmYWxzZSIKICAgICBmaXQtbWFyZ2luLXRvcD0iMCIKICAgICBmaXQtbWFyZ2luLWxlZnQ9IjAiCiAgICAgZml0LW1hcmdpbi1yaWdodD0iMCIKICAgICBmaXQtbWFyZ2luLWJvdHRvbT0iMCIKICAgICBpbmtzY2FwZTp6b29tPSIxLjM2OTIwODQiCiAgICAgaW5rc2NhcGU6Y3g9IjQ4Mi43NjA3MSIKICAgICBpbmtzY2FwZTpjeT0iOTIuNzQ5NDY5IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNyIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9IkxheWVyXzEiIC8+CiAgPGRlZnMKICAgICBpZD0iZGVmczQ2MTEiPgogICAgPHN0eWxlCiAgICAgICBpZD0ic3R5bGU0NjA5Ij4uY2xzLTF7ZmlsbDojMmFkZmMzO30uY2xzLTJ7ZmlsbDojMjg3ZWZiO30uY2xzLTN7ZmlsbDojMzg0NzQ1O308L3N0eWxlPgogIDwvZGVmcz4KICA8dGl0bGUKICAgICBpZD0idGl0bGU0NjEzIj5sb2dvPC90aXRsZT4KICA8ZwogICAgIGlkPSJMYXllcl8xIgogICAgIGRhdGEtbmFtZT0iTGF5ZXIgMSI+CiAgICA8cGF0aAogICAgICAgY2xhc3M9ImNscy0xIgogICAgICAgZD0iTSAxNzYuNjM0NDQsOC44NjQ1MyBWIDE3Ni42MzQ0MSBIIDguODY0NTMgViA4Ljg2NDUzIGggMTY3Ljc2OTkxIG0gMCwtOC44NjQ1MyBIIDguODY0NTMgQSA4Ljg2NDU2LDguODY0NTYgMCAwIDAgMCw4Ljg2NDUzIHYgMTY3Ljc2OTg4IGEgOC44NjQ1Niw4Ljg2NDU2IDAgMCAwIDguODY0NTMsOC44NjQ1MyBoIDE2Ny43Njk5MSBhIDguODY0NTUsOC44NjQ1NSAwIDAgMCA4Ljg2NDUzLC04Ljg2NDUzIFYgOC44NjQ1MyBBIDguODY0NTUsOC44NjQ1NSAwIDAgMCAxNzYuNjM0NDQsMCBaIgogICAgICAgaWQ9InBhdGg0NjE1IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHN0eWxlPSJmaWxsOiMyYWRmYzMiIC8+CiAgICA8cGF0aAogICAgICAgY2xhc3M9ImNscy0yIgogICAgICAgZD0ibSAxMDUuNjc1NTcsMTMxLjM0NDUxIGggLTgyLjAzNyBWIDEyMi40OCBoIDgwLjIwNzU0IGwgMjMuMjkzNjMsLTIzLjE3ODIgYSA0LjQzMTgzLDQuNDMxODMgMCAwIDEgMy4xMjYyNSwtMS4yOTA0NCBoIDMxLjU5NDMxIHYgOC44NjQ1MyBoIC0yOS43NjQ4NSBsIC0yMy4yOTM2MywyMy4xNzgyMSBhIDQuNDMyMzcsNC40MzIzNyAwIDAgMSAtMy4xMjYyNSwxLjI5MDQxIHoiCiAgICAgICBpZD0icGF0aDQ2MTciCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc3R5bGU9ImZpbGw6IzI4N2VmYiIgLz4KICAgIDxwYXRoCiAgICAgICBjbGFzcz0iY2xzLTIiCiAgICAgICBkPSJNIDExNy44NzIzOCwxNjAuODkyOTQgSCAyMy42Mzg1NyB2IC04Ljg2NDUzIGggOTIuNDA0MzUgbCAyMy4yOTM2MywtMjMuMTc4MiBhIDQuNDMxODMsNC40MzE4MyAwIDAgMSAzLjEyNjI0LC0xLjI5MDQ0IGggMTkuMzk3NTEgdiA4Ljg2NDUzIGggLTE3LjU2OCBsIC0yMy4yOTM2MywyMy4xNzgyMSBhIDQuNDMxODcsNC40MzE4NyAwIDAgMSAtMy4xMjYyOSwxLjI5MDQzIHoiCiAgICAgICBpZD0icGF0aDQ2MTkiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc3R5bGU9ImZpbGw6IzI4N2VmYiIgLz4KICAgIDxwYXRoCiAgICAgICBjbGFzcz0iY2xzLTIiCiAgICAgICBkPSJNIDQ5LjEzNDE5LDcyLjcxMjggSCAyMy42Mzg1NyB2IC04Ljg2NDUzIGggMjMuNjY2MTUgbCAyMy4yOTQyMSwtMjMuMTc4MiBhIDQuNDMyMzgsNC40MzIzOCAwIDAgMSAzLjEyNjI1LC0xLjI5MDQ0IGggODguMTM1MTIgdiA4Ljg2NDUzIEggNzUuNTU0NjQgTCA1Mi4yNjA0Myw3MS40MjIzNyBhIDQuNDMyMzUsNC40MzIzNSAwIDAgMSAtMy4xMjYyNCwxLjI5MDQzIHoiCiAgICAgICBpZD0icGF0aDQ2MjEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgc3R5bGU9ImZpbGw6IzI4N2VmYiIgLz4KICAgIDxwYXRoCiAgICAgICBjbGFzcz0iY2xzLTEiCiAgICAgICBkPSJtIDE2MS44NjAzLDEwNi44NzU4NyBoIC0xOS42NDIyIGEgNC40MzIzNCw0LjQzMjM0IDAgMCAxIC0zLjEyNjI1LC0xLjI5MDQ0IEwgMTE1Ljc5ODIyLDgyLjQwNzIzIEggODAuMDY4MjggQSA0LjQzMjM0LDQuNDMyMzQgMCAwIDEgNzYuOTQyLDgxLjExNjc5IEwgNTMuNjQ3OCw1Ny45Mzg1OSBIIDIzLjYzODU3IHYgLTguODY0NTMgaCAzMS44Mzg3MiBhIDQuNDMyMzksNC40MzIzOSAwIDAgMSAzLjEyNjI1LDEuMjkwNDMgbCAyMy4yOTQyLDIzLjE3ODIxIGggMzUuNzI5OTQgYSA0LjQzMTg3LDQuNDMxODcgMCAwIDEgMy4xMjYyNSwxLjI5MDQzIGwgMjMuMjkzNjMsMjMuMTc4MjEgaCAxNy44MTI3NCB6IgogICAgICAgaWQ9InBhdGg0NjIzIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHN0eWxlPSJmaWxsOiMyYWRmYzMiIC8+CiAgICA8cGF0aAogICAgICAgY2xhc3M9ImNscy0xIgogICAgICAgZD0ibSAxNjEuODYwMywxMzYuNDI0MyBoIC0zMS44MzkgYSA0LjQzMTg3LDQuNDMxODcgMCAwIDEgLTMuMTI2MjUsLTEuMjkwNDMgTCAxMDMuNjAxNDIsMTExLjk1NTY2IEggNjcuODcyMDUgQSA0LjQzMjM3LDQuNDMyMzcgMCAwIDEgNjQuNzQ1OCwxMTAuNjY1MjMgTCA0MS40NTE1OSw4Ny40ODcgaCAtMTcuODEzIHYgLTguODY0NTEgaCAxOS42NDI0NyBhIDQuNDMyMzYsNC40MzIzNiAwIDAgMSAzLjEyNjI1LDEuMjkwNDQgbCAyMy4yOTQyLDIzLjE3ODIgaCAzNS43MjkzNiBhIDQuNDMyMzQsNC40MzIzNCAwIDAgMSAzLjEyNjI1LDEuMjkwNDQgbCAyMy4yOTM2MywyMy4xNzgyIGggMzAuMDA5NTUgeiIKICAgICAgIGlkPSJwYXRoNDYyNSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzdHlsZT0iZmlsbDojMmFkZmMzIiAvPgogICAgPHBhdGgKICAgICAgIGNsYXNzPSJjbHMtMSIKICAgICAgIGQ9Ik0gMTYxLjg2MDMsMTIxLjY1MDA5IEggMTM2LjEyIGEgNC40MzI0LDQuNDMyNCAwIDAgMSAtMy4xMjYyNSwtMS4yOTA0NCBMIDEwOS42OTk1NSw5Ny4xODE0NCBIIDczLjk2OTg3IEEgNC40MzIzNyw0LjQzMjM3IDAgMCAxIDcwLjg0MzYzLDk1Ljg5MSBMIDQ3LjU0OTQyLDcyLjcxMjggSCAyMy42Mzg1NyB2IC04Ljg2NDUzIGggMjUuNzQwMzEgYSA0LjQzMjM4LDQuNDMyMzggMCAwIDEgMy4xMjYyNSwxLjI5MDQ0IEwgNzUuNzk5MzQsODguMzE2OTIgSCAxMTEuNTI5IGEgNC40MzE4OCw0LjQzMTg4IDAgMCAxIDMuMTI2MjUsMS4yOTA0MyBsIDIzLjI5NDIsMjMuMTc4MjEgaCAyMy45MTA4NSB6IgogICAgICAgaWQ9InBhdGg0NjI3IgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHN0eWxlPSJmaWxsOiMyYWRmYzMiIC8+CiAgICA8cGF0aAogICAgICAgY2xhc3M9ImNscy0yIgogICAgICAgZD0iTSAxMTEuNzczNjksMTQ2LjExODczIEggMjMuNjM4NTcgdiAtOC44NjQ1MyBoIDg2LjMwNTY1IGwgMjMuMjk0MjEsLTIzLjE3ODIgYSA0LjQzMjM3LDQuNDMyMzcgMCAwIDEgMy4xMjYyNSwtMS4yOTA0MyBoIDI1LjQ5NTYyIHYgOC44NjQ1MyBoIC0yMy42NjYxNiBsIC0yMy4yOTQyLDIzLjE3ODIgYSA0LjQzMjQsNC40MzI0IDAgMCAxIC0zLjEyNjI1LDEuMjkwNDMgeiIKICAgICAgIGlkPSJwYXRoNDYyOSIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzdHlsZT0iZmlsbDojMjg3ZWZiIiAvPgogICAgPHBhdGgKICAgICAgIGNsYXNzPSJjbHMtMiIKICAgICAgIGQ9Ik0gNDMuMDM2MzYsNTcuOTM4NTkgSCAyMy42Mzg1NyBWIDQ5LjA3NDA2IEggNDEuMjA2OSBMIDY0LjUwMTEsMjUuODk2NDMgQSA0LjQzMjQsNC40MzI0IDAgMCAxIDY3LjYyNzM1LDI0LjYwNiBoIDk0LjIzMjk1IHYgOC44NjQ1MyBIIDY5LjQ1NjgxIGwgLTIzLjI5NDIsMjMuMTc3NjIgYSA0LjQzMjM2LDQuNDMyMzYgMCAwIDEgLTMuMTI2MjUsMS4yOTA0NCB6IgogICAgICAgaWQ9InBhdGg0NjMxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIHN0eWxlPSJmaWxsOiMyODdlZmIiIC8+CiAgICA8cGF0aAogICAgICAgY2xhc3M9ImNscy0yIgogICAgICAgZD0iTSA1NS4yMzIsODcuNDg3IEggMjMuNjM4NTcgdiAtOC44NjQ1MSBoIDI5Ljc2NCBMIDc2LjY5Njc2LDU1LjQ0NDg2IEEgNC40MzIzNSw0LjQzMjM1IDAgMCAxIDc5LjgyMyw1NC4xNTQ0MyBoIDgyLjAzNzMgViA2My4wMTkgSCA4MS42NTI0NyBMIDU4LjM1ODI2LDg2LjE5NjU4IEEgNC40MzIzNCw0LjQzMjM0IDAgMCAxIDU1LjIzMiw4Ny40ODcgWiIKICAgICAgIGlkPSJwYXRoNDYzMyIKICAgICAgIGlua3NjYXBlOmNvbm5lY3Rvci1jdXJ2YXR1cmU9IjAiCiAgICAgICBzdHlsZT0iZmlsbDojMjg3ZWZiIiAvPgogIDwvZz4KPC9zdmc+Cg==\",\"mediatype\":\"image/svg+xml\"}],\"install\":{\"spec\":{\"clusterPermissions\":[{\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"configmaps\"],\"verbs\":[\"get\",\"list\",\"watch\",\"update\"]},{\"apiGroups\":[\"apiextensions.k8s.io\"],\"resources\":[\"customresourcedefinitions\"],\"verbs\":[\"get\",\"list\",\"create\",\"update\",\"delete\"]},{\"apiGroups\":[\"\"],\"resources\":[\"pods\",\"services\"],\"verbs\":[\"get\",\"list\",\"watch\"]},{\"apiGroups\":[\"operator.openshift.io\"],\"resources\":[\"dnses\"],\"verbs\":[\"get\",\"list\",\"watch\",\"update\"]},{\"apiGroups\":[\"config.openshift.io\"],\"resources\":[\"networks\"],\"verbs\":[\"get\",\"list\"]},{\"apiGroups\":[\"\"],\"resources\":[\"pods\",\"services\",\"namespaces\",\"nodes\"],\"verbs\":[\"get\",\"list\",\"watch\",\"update\"]},{\"apiGroups\":[\"submariner.io\"],\"resources\":[\"endpoints\",\"clusters\"],\"verbs\":[\"get\",\"list\",\"watch\"]},{\"apiGroups\":[\"lighthouse.submariner.io\"],\"resources\":[\"serviceexports\"],\"verbs\":[\"get\",\"list\",\"watch\"]}],\"serviceAccountName\":\"submariner-operator\"}],\"deployments\":[{\"name\":\"submariner-operator\",\"spec\":{\"replicas\":1,\"selector\":{\"matchLabels\":{\"control-plane\":\"submariner-operator\"}},\"strategy\":{},\"template\":{\"metadata\":{\"labels\":{\"control-plane\":\"submariner-operator\"}},\"spec\":{\"containers\":[{\"command\":[\"submariner-operator\"],\"env\":[{\"name\":\"WATCH_NAMESPACE\",\"valueFrom\":{\"fieldRef\":{\"fieldPath\":\"metadata.annotations['olm.targetNamespaces']\"}}},{\"name\":\"POD_NAME\",\"valueFrom\":{\"fieldRef\":{\"fieldPath\":\"metadata.name\"}}},{\"name\":\"OPERATOR_NAME\",\"value\":\"submariner-operator\"}],\"image\":\"registry.redhat.io/rhacm2-tech-preview/submariner-rhel8-operator@sha256:3bf59d5e45e4d01e92e96073d7234d6e6b535a5e7b4d41c352076a6ea50012c7\",\"imagePullPolicy\":\"Always\",\"name\":\"submariner-operator\",\"resources\":{}}],\"serviceAccountName\":\"submariner-operator\"}}}}],\"permissions\":[{\"rules\":[{\"apiGroups\":[\"\"],\"resources\":[\"pods\",\"services\",\"services/finalizers\",\"endpoints\",\"persistentvolumeclaims\",\"events\",\"configmaps\",\"secrets\"],\"verbs\":[\"*\"]},{\"apiGroups\":[\"apps\"],\"resources\":[\"deployments\",\"daemonsets\",\"replicasets\",\"statefulsets\"],\"verbs\":[\"*\"]},{\"apiGroups\":[\"monitoring.coreos.com\"],\"resources\":[\"servicemonitors\"],\"verbs\":[\"get\",\"create\"]},{\"apiGroups\":[\"apps\"],\"resourceNames\":[\"submariner-operator\"],\"resources\":[\"deployments/finalizers\"],\"verbs\":[\"update\"]},{\"apiGroups\":[\"\"],\"resources\":[\"pods\"],\"verbs\":[\"get\"]},{\"apiGroups\":[\"apps\"],\"resources\":[\"replicasets\"],\"verbs\":[\"get\"]},{\"apiGroups\":[\"submariner.io\"],\"resources\":[\"*\",\"servicediscoveries\"],\"verbs\":[\"*\"]},{\"apiGroups\":[\"lighthouse.submariner.io\"],\"resources\":[\"*\",\"serviceexports\"],\"verbs\":[\"create\",\"delete\",\"get\",\"list\",\"patch\",\"update\",\"watch\"]}],\"serviceAccountName\":\"submariner-operator\"}]},\"strategy\":\"deployment\"},\"installModes\":[{\"supported\":true,\"type\":\"OwnNamespace\"},{\"supported\":true,\"type\":\"SingleNamespace\"},{\"supported\":false,\"type\":\"MultiNamespace\"},{\"supported\":true,\"type\":\"AllNamespaces\"}],\"keywords\":[\"multi-cluster\",\"ipsec\",\"tunnel\",\"submariner-operator\"],\"labels\":{\"name\":\"submariner-operator\"},\"links\":[{\"name\":\"Website\",\"url\":\"https://submariner.io\"},{\"name\":\"GitHub\",\"url\":\"https://github.com/submariner-io\"},{\"name\":\"Slack\",\"url\":\"https://kubernetes.slack.com/archives/C010RJV694M\"},{\"name\":\"YouTube\",\"url\":\"https://www.youtube.com/channel/UCZ3brSgl2v4boglZoeChClQ/videos\"},{\"name\":\"Twitter\",\"url\":\"https://twitter.com/submarinerio\"}],\"maintainers\":[{\"email\":\"submariner-dev@googlegroups.com\",\"name\":\"Submariner project\"}],\"maturity\":\"alpha\",\"provider\":{\"name\":\"Red Hat\"},\"relatedImages\":[{\"image\":\"registry.redhat.io/rhacm2-tech-preview/submariner-rhel8-operator@sha256:3bf59d5e45e4d01e92e96073d7234d6e6b535a5e7b4d41c352076a6ea50012c7\",\"name\":\"submariner-rhel8-operator-3bf59d5e45e4d01e92e96073d7234d6e6b535a5e7b4d41c352076a6ea50012c7-annotation\"},{\"image\":\"registry.redhat.io/rhacm2-tech-preview/submariner-rhel8-operator@sha256:3bf59d5e45e4d01e92e96073d7234d6e6b535a5e7b4d41c352076a6ea50012c7\",\"name\":\"submariner-operator\"}],\"selector\":{\"matchLabels\":{\"control-plane\":\"submariner-operator\"}},\"version\":\"0.8.1\"}}",
  "bundlePath": "registry.redhat.io/datagrid/datagrid-8-prod-operator-bundle@sha256:b35b91095373da362968febdfe8d977930d4046e6cd3798960544ada025a665a",
  "providedApis": [
    {
      "group": "infinispan.org",
      "version": "v1",
      "kind": "Infinispan",
      "plural": "infinispans"
    },
    {
      "group": "infinispan.org",
      "version": "v2alpha1",
      "kind": "Restore",
      "plural": "restores"
    },
    {
      "group": "infinispan.org",
      "version": "v2alpha1",
      "kind": "Backup",
      "plural": "backups"
    },
    {
      "group": "infinispan.org",
      "version": "v2alpha1",
      "kind": "Batch",
      "plural": "batches"
    },
    {
      "group": "infinispan.org",
      "version": "v2alpha1",
      "kind": "Cache",
      "plural": "caches"
    }
  ],
  "version": "8.2.0"
}
